<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ariths_gen.core.arithmetic_circuits.multiplier_circuit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ariths_gen.core.arithmetic_circuits.multiplier_circuit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .arithmetic_circuit import (
    ArithmeticCircuit
)

from ariths_gen.one_bit_circuits.logic_gates import (
    AndGate,
    NandGate,
    OrGate,
    NorGate,
    XorGate,
    XnorGate,
    NotGate
)

from ariths_gen.wire_components import (
    Wire,
    ConstantWireValue0,
    ConstantWireValue1,
    Bus
)

import math


class MultiplierCircuit(ArithmeticCircuit):
    &#34;&#34;&#34;Class represents a general multiplier circuit derived from `ArithmeticCircuit` class.

    The __init__ method calls parent class __init__ method which fills some mandatory attributes concerning arithmetic circuit
    that are later used for generation into various representations.
    &#34;&#34;&#34;

    def __init__(self, a, b, prefix, name, out_N, **kwargs):
        super().__init__(a=a, b=b, prefix=prefix, name=name, out_N=out_N, **kwargs)

    # Array multipliers
    def get_previous_partial_product(self, a_index: int, b_index: int):
        &#34;&#34;&#34;Used in array multipliers to get previous row&#39;s component output wires for further connection to another component&#39;s input.

        Args:
            a_index (int): First input wire index.
            b_index (int): Second input wire index.

        Returns:
            Wire: Previous row&#39;s component wire of corresponding pp.
        &#34;&#34;&#34;
        # To get the index of previous row&#39;s connecting adder and its generated pp
        index = ((b_index-2) * (self.N*2)) + ((self.N-1)+2*(a_index+2))

        # Get carry wire as input for the last adder in current row
        if a_index == self.N-1:
            index = index-2
            return self.components[index].get_carry_wire()
        # Get sum wire as input for current adder
        else:
            return self.components[index].get_sum_wire()

    # Dadda/Wallace multipliers
    @staticmethod
    def get_maximum_height(initial_value: int):
        &#34;&#34;&#34;Used in dadda multipliers to get multiplier&#39;s maximum height.

        Maximum height sequence as defined here: https://en.wikipedia.org/wiki/Dadda_multiplier
        d(j=1) = 2; d(j+1) = floor(1.5*d)

        `j` stands for initial stage value
        `d` stands for maximum height for current initial stage value

        Args:
            initial_value (int): Initial algorithms stage value.

        Returns:
            int, int: Current algorithms stage and maximum bits (height) allowed in a column for current stage.
        &#34;&#34;&#34;
        stage = 0
        d = 2
        while True:
            stage += 1
            max_height = d
            # Calculating maximum height sequence
            # d(j=1) = 2; d(j+1) = floor(1.5*d)
            d = math.floor(1.5*d)
            if d &gt;= initial_value:
                return stage, max_height

    def init_column_heights(self, signed: bool = False):
        &#34;&#34;&#34;Creates appropriate number of partial product columns along with filling them with corresponding number of bit pairs.

        Args:
            signed (bool, optional): Specify whether pp columns bit pairs should perform signed multiplication or not. Defaults to False.

        Returns:
            list: List of partial product columns with their bit pairs.
        &#34;&#34;&#34;
        columns = [[num] if num &lt;= self.N else [num - (num - self.N)*2] for num in range(1, self.out.N)]
        columns = [self.add_column_wires(column=col, column_index=columns.index(col), signed=signed) for col in columns]
        return columns

    def add_column_wires(self, column: list, column_index: int, signed: bool):
        &#34;&#34;&#34;Fills circuit&#39;s partial product column with corresponding bit pairs.

        Args:
            column (list): List representing column of partial product bits.
            column_index (int): Index of partial products column.
            signed (bool): Specify whether pp columns bit pairs should perform signed multiplication or not.

        Returns:
            list: Updated column list containing corresponding number of input bit pairs to form proper pp column.
        &#34;&#34;&#34;
        # Adding neccessary number of lists (based on number of bits in the column – stored in `column[0]`)
        # to column that each represent individual bit pairs for described column (these bit pairs are then combined in AND/NAND gates)
        [column.append([]) for _ in range(column[0])]
        # Filling column bit pair lists with appropriate bits
        if column_index &lt;= self.N-1:
            [column[column[0]-index].append(self.a.get_wire(index)) for index in range(0, column[0])]
            [column[index+1].append(self.b.get_wire(index)) for index in range(0, column[0])]
        else:
            [column[self.a.N-index].append(self.a.get_wire(index)) for index in range(self.a.N-1, self.a.N-column[0]-1, -1)]
            [column[index-(self.a.N-1-column[0])].append(self.b.get_wire(index)) for index in range(self.a.N-column[0], self.a.N)]

        # Converting unsigned column pp bit pair lists into AND gates
        if signed is False:
            column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
        # Converting signed column pp bit pair lists into AND/NAND gates (based on Baugh-Wooley multiplication algorithm)
        else:
            # First half of partial product columns contains only AND gates
            if column_index &lt; self.N-1 or column_index == self.out.N-2:
                column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
            # Second half of partial product columns contains NAND/AND gates
            else:
                column[1] = NandGate(a=column[1][0], b=column[1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[1][0].index)+&#39;_&#39;+str(column[1][1].index), parent_component=self)
                column[-1] = NandGate(a=column[-1][0], b=column[-1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[-1][0].index)+&#39;_&#39;+str(column[-1][1].index), parent_component=self)
                if len(column[2:-1]) != 0:
                    column[2:-1] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(2, len(column)-1)]

        return column

    def get_column_height(self, column_num: int):
        &#34;&#34;&#34;Retrieves the current height of desired partial products column.

        Args:
            column_num (int): Index of pp column.

        Returns:
            int: Height of the current bit column.
        &#34;&#34;&#34;
        return self.columns[column_num][0]

    def update_column_heights(self, curr_column: int, curr_height_change: int, next_column: int = 0, next_height_change: int = 0):
        &#34;&#34;&#34;Updates height of desired column and optionally also its subsequent column.

        Used within dadda and wallace multipliers to perform gradual reduction of partial product columns through the stages.
        Allows to choose the height change to take effect on the chosen column index and optionally also the same for the following
        column if it should also be affected.

        Args:
            curr_column (int): Current pp column index.
            curr_height_change (int): Height change for the chosen current pp column.
            next_column (int, optional): Subsequent pp column index. Defaults to 0.
            next_height_change (int, optional): Height change for the chosen subsequent pp column. Defaults to 0.
        &#34;&#34;&#34;
        self.columns[curr_column][0] = self.get_column_height(curr_column)+curr_height_change
        if next_column-1 == curr_column:
            self.columns[next_column][0] = self.get_column_height(next_column)+next_height_change

    def add_column_wire(self, column: int, bit: int):
        &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

        If bit pair (AND/NAND gate) is present at the desired position, it is reduced and replaced with AND/NAND gate output wire accordingly.
        Either former logic gate&#39;s output wire or present wire is returned.

        Args:
            column (int): Partial product column index.
            bit (int): Bit position within the chosen column.

        Returns:
            Wire: Return Wire present at specified position.
        &#34;&#34;&#34;
        # Checks if a logic gate is present at desired column bit position. If so the gate is added to circuit&#39;s list of subcomponents,
        # and the former logic gates&#39;s output bit replaces the gate at desired column bit position. This output wire is also returned to the caller.
        if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
            self.add_component(self.columns[column][bit+1])
            return self.get_previous_component(1).out
        else:
            return self.columns[column][bit+1]

    def get_column_wire(self, column: int, bit: int):
        &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

        If bit pair (AND/NAND gate) is present at the desired position, AND/NAND gate output wire is returned,
        if not the wire present at the desired position is returned.

        Args:
            column (int): Partial product column index.
            bit (int): Bit position within the chosen column.

        Returns:
            Wire: Return Wire present at specified position.
        &#34;&#34;&#34;
        # Checks if a logic gate is present at desired column bit position. If so, its output bit is returned.
        if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
            return self.columns[column][bit+1].out
        else:
            return self.columns[column][bit+1]

    def update_column_wires(self, curr_column: int, adder: ArithmeticCircuit, next_column: int = 0):
        &#34;&#34;&#34;Provides bit height reduction of the chosen column.

        Inserts chosen column&#39;s top bits into an `adder` circuit to reduce its bit height.
        Generated sum is stored to the bottom of the column and generated carry bit is stored to the top of the next column.

        Args:
            curr_column (int): Current pp column index.
            adder (ArithmeticCircuit): Two/three input one bit adder.
            next_column (int, optional): Subsequent pp column index. Defaults to 0.
        &#34;&#34;&#34;
        if hasattr(adder, &#34;c&#34;):
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())
        else:
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())

        if next_column-1 == curr_column:
            self.columns[next_column].insert(1, adder.get_carry_wire())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit"><code class="flex name class">
<span>class <span class="ident">MultiplierCircuit</span></span>
<span>(</span><span>a, b, prefix, name, out_N, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Class represents a general multiplier circuit derived from <code>ArithmeticCircuit</code> class.</p>
<p>The <strong>init</strong> method calls parent class <strong>init</strong> method which fills some mandatory attributes concerning arithmetic circuit
that are later used for generation into various representations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiplierCircuit(ArithmeticCircuit):
    &#34;&#34;&#34;Class represents a general multiplier circuit derived from `ArithmeticCircuit` class.

    The __init__ method calls parent class __init__ method which fills some mandatory attributes concerning arithmetic circuit
    that are later used for generation into various representations.
    &#34;&#34;&#34;

    def __init__(self, a, b, prefix, name, out_N, **kwargs):
        super().__init__(a=a, b=b, prefix=prefix, name=name, out_N=out_N, **kwargs)

    # Array multipliers
    def get_previous_partial_product(self, a_index: int, b_index: int):
        &#34;&#34;&#34;Used in array multipliers to get previous row&#39;s component output wires for further connection to another component&#39;s input.

        Args:
            a_index (int): First input wire index.
            b_index (int): Second input wire index.

        Returns:
            Wire: Previous row&#39;s component wire of corresponding pp.
        &#34;&#34;&#34;
        # To get the index of previous row&#39;s connecting adder and its generated pp
        index = ((b_index-2) * (self.N*2)) + ((self.N-1)+2*(a_index+2))

        # Get carry wire as input for the last adder in current row
        if a_index == self.N-1:
            index = index-2
            return self.components[index].get_carry_wire()
        # Get sum wire as input for current adder
        else:
            return self.components[index].get_sum_wire()

    # Dadda/Wallace multipliers
    @staticmethod
    def get_maximum_height(initial_value: int):
        &#34;&#34;&#34;Used in dadda multipliers to get multiplier&#39;s maximum height.

        Maximum height sequence as defined here: https://en.wikipedia.org/wiki/Dadda_multiplier
        d(j=1) = 2; d(j+1) = floor(1.5*d)

        `j` stands for initial stage value
        `d` stands for maximum height for current initial stage value

        Args:
            initial_value (int): Initial algorithms stage value.

        Returns:
            int, int: Current algorithms stage and maximum bits (height) allowed in a column for current stage.
        &#34;&#34;&#34;
        stage = 0
        d = 2
        while True:
            stage += 1
            max_height = d
            # Calculating maximum height sequence
            # d(j=1) = 2; d(j+1) = floor(1.5*d)
            d = math.floor(1.5*d)
            if d &gt;= initial_value:
                return stage, max_height

    def init_column_heights(self, signed: bool = False):
        &#34;&#34;&#34;Creates appropriate number of partial product columns along with filling them with corresponding number of bit pairs.

        Args:
            signed (bool, optional): Specify whether pp columns bit pairs should perform signed multiplication or not. Defaults to False.

        Returns:
            list: List of partial product columns with their bit pairs.
        &#34;&#34;&#34;
        columns = [[num] if num &lt;= self.N else [num - (num - self.N)*2] for num in range(1, self.out.N)]
        columns = [self.add_column_wires(column=col, column_index=columns.index(col), signed=signed) for col in columns]
        return columns

    def add_column_wires(self, column: list, column_index: int, signed: bool):
        &#34;&#34;&#34;Fills circuit&#39;s partial product column with corresponding bit pairs.

        Args:
            column (list): List representing column of partial product bits.
            column_index (int): Index of partial products column.
            signed (bool): Specify whether pp columns bit pairs should perform signed multiplication or not.

        Returns:
            list: Updated column list containing corresponding number of input bit pairs to form proper pp column.
        &#34;&#34;&#34;
        # Adding neccessary number of lists (based on number of bits in the column – stored in `column[0]`)
        # to column that each represent individual bit pairs for described column (these bit pairs are then combined in AND/NAND gates)
        [column.append([]) for _ in range(column[0])]
        # Filling column bit pair lists with appropriate bits
        if column_index &lt;= self.N-1:
            [column[column[0]-index].append(self.a.get_wire(index)) for index in range(0, column[0])]
            [column[index+1].append(self.b.get_wire(index)) for index in range(0, column[0])]
        else:
            [column[self.a.N-index].append(self.a.get_wire(index)) for index in range(self.a.N-1, self.a.N-column[0]-1, -1)]
            [column[index-(self.a.N-1-column[0])].append(self.b.get_wire(index)) for index in range(self.a.N-column[0], self.a.N)]

        # Converting unsigned column pp bit pair lists into AND gates
        if signed is False:
            column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
        # Converting signed column pp bit pair lists into AND/NAND gates (based on Baugh-Wooley multiplication algorithm)
        else:
            # First half of partial product columns contains only AND gates
            if column_index &lt; self.N-1 or column_index == self.out.N-2:
                column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
            # Second half of partial product columns contains NAND/AND gates
            else:
                column[1] = NandGate(a=column[1][0], b=column[1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[1][0].index)+&#39;_&#39;+str(column[1][1].index), parent_component=self)
                column[-1] = NandGate(a=column[-1][0], b=column[-1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[-1][0].index)+&#39;_&#39;+str(column[-1][1].index), parent_component=self)
                if len(column[2:-1]) != 0:
                    column[2:-1] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(2, len(column)-1)]

        return column

    def get_column_height(self, column_num: int):
        &#34;&#34;&#34;Retrieves the current height of desired partial products column.

        Args:
            column_num (int): Index of pp column.

        Returns:
            int: Height of the current bit column.
        &#34;&#34;&#34;
        return self.columns[column_num][0]

    def update_column_heights(self, curr_column: int, curr_height_change: int, next_column: int = 0, next_height_change: int = 0):
        &#34;&#34;&#34;Updates height of desired column and optionally also its subsequent column.

        Used within dadda and wallace multipliers to perform gradual reduction of partial product columns through the stages.
        Allows to choose the height change to take effect on the chosen column index and optionally also the same for the following
        column if it should also be affected.

        Args:
            curr_column (int): Current pp column index.
            curr_height_change (int): Height change for the chosen current pp column.
            next_column (int, optional): Subsequent pp column index. Defaults to 0.
            next_height_change (int, optional): Height change for the chosen subsequent pp column. Defaults to 0.
        &#34;&#34;&#34;
        self.columns[curr_column][0] = self.get_column_height(curr_column)+curr_height_change
        if next_column-1 == curr_column:
            self.columns[next_column][0] = self.get_column_height(next_column)+next_height_change

    def add_column_wire(self, column: int, bit: int):
        &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

        If bit pair (AND/NAND gate) is present at the desired position, it is reduced and replaced with AND/NAND gate output wire accordingly.
        Either former logic gate&#39;s output wire or present wire is returned.

        Args:
            column (int): Partial product column index.
            bit (int): Bit position within the chosen column.

        Returns:
            Wire: Return Wire present at specified position.
        &#34;&#34;&#34;
        # Checks if a logic gate is present at desired column bit position. If so the gate is added to circuit&#39;s list of subcomponents,
        # and the former logic gates&#39;s output bit replaces the gate at desired column bit position. This output wire is also returned to the caller.
        if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
            self.add_component(self.columns[column][bit+1])
            return self.get_previous_component(1).out
        else:
            return self.columns[column][bit+1]

    def get_column_wire(self, column: int, bit: int):
        &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

        If bit pair (AND/NAND gate) is present at the desired position, AND/NAND gate output wire is returned,
        if not the wire present at the desired position is returned.

        Args:
            column (int): Partial product column index.
            bit (int): Bit position within the chosen column.

        Returns:
            Wire: Return Wire present at specified position.
        &#34;&#34;&#34;
        # Checks if a logic gate is present at desired column bit position. If so, its output bit is returned.
        if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
            return self.columns[column][bit+1].out
        else:
            return self.columns[column][bit+1]

    def update_column_wires(self, curr_column: int, adder: ArithmeticCircuit, next_column: int = 0):
        &#34;&#34;&#34;Provides bit height reduction of the chosen column.

        Inserts chosen column&#39;s top bits into an `adder` circuit to reduce its bit height.
        Generated sum is stored to the bottom of the column and generated carry bit is stored to the top of the next column.

        Args:
            curr_column (int): Current pp column index.
            adder (ArithmeticCircuit): Two/three input one bit adder.
            next_column (int, optional): Subsequent pp column index. Defaults to 0.
        &#34;&#34;&#34;
        if hasattr(adder, &#34;c&#34;):
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())
        else:
            self.columns[curr_column].pop(1)
            self.columns[curr_column].pop(1)
            self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())

        if next_column-1 == curr_column:
            self.columns[next_column].insert(1, adder.get_carry_wire())</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit">ArithmeticCircuit</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="ariths_gen.multi_bit_circuits.multipliers.array_multiplier.SignedArrayMultiplier" href="../../multi_bit_circuits/multipliers/array_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.array_multiplier.SignedArrayMultiplier">SignedArrayMultiplier</a></li>
<li><a title="ariths_gen.multi_bit_circuits.multipliers.array_multiplier.UnsignedArrayMultiplier" href="../../multi_bit_circuits/multipliers/array_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.array_multiplier.UnsignedArrayMultiplier">UnsignedArrayMultiplier</a></li>
<li><a title="ariths_gen.multi_bit_circuits.multipliers.dadda_multiplier.SignedDaddaMultiplier" href="../../multi_bit_circuits/multipliers/dadda_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.dadda_multiplier.SignedDaddaMultiplier">SignedDaddaMultiplier</a></li>
<li><a title="ariths_gen.multi_bit_circuits.multipliers.dadda_multiplier.UnsignedDaddaMultiplier" href="../../multi_bit_circuits/multipliers/dadda_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.dadda_multiplier.UnsignedDaddaMultiplier">UnsignedDaddaMultiplier</a></li>
<li><a title="ariths_gen.multi_bit_circuits.multipliers.wallace_multiplier.SignedWallaceMultiplier" href="../../multi_bit_circuits/multipliers/wallace_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.wallace_multiplier.SignedWallaceMultiplier">SignedWallaceMultiplier</a></li>
<li><a title="ariths_gen.multi_bit_circuits.multipliers.wallace_multiplier.UnsignedWallaceMultiplier" href="../../multi_bit_circuits/multipliers/wallace_multiplier.html#ariths_gen.multi_bit_circuits.multipliers.wallace_multiplier.UnsignedWallaceMultiplier">UnsignedWallaceMultiplier</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_maximum_height"><code class="name flex">
<span>def <span class="ident">get_maximum_height</span></span>(<span>initial_value: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Used in dadda multipliers to get multiplier's maximum height.</p>
<p>Maximum height sequence as defined here: <a href="https://en.wikipedia.org/wiki/Dadda_multiplier">https://en.wikipedia.org/wiki/Dadda_multiplier</a>
d(j=1) = 2; d(j+1) = floor(1.5*d)</p>
<p><code>j</code> stands for initial stage value
<code>d</code> stands for maximum height for current initial stage value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>initial_value</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial algorithms stage value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int, int</code></dt>
<dd>Current algorithms stage and maximum bits (height) allowed in a column for current stage.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_maximum_height(initial_value: int):
    &#34;&#34;&#34;Used in dadda multipliers to get multiplier&#39;s maximum height.

    Maximum height sequence as defined here: https://en.wikipedia.org/wiki/Dadda_multiplier
    d(j=1) = 2; d(j+1) = floor(1.5*d)

    `j` stands for initial stage value
    `d` stands for maximum height for current initial stage value

    Args:
        initial_value (int): Initial algorithms stage value.

    Returns:
        int, int: Current algorithms stage and maximum bits (height) allowed in a column for current stage.
    &#34;&#34;&#34;
    stage = 0
    d = 2
    while True:
        stage += 1
        max_height = d
        # Calculating maximum height sequence
        # d(j=1) = 2; d(j+1) = floor(1.5*d)
        d = math.floor(1.5*d)
        if d &gt;= initial_value:
            return stage, max_height</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wire"><code class="name flex">
<span>def <span class="ident">add_column_wire</span></span>(<span>self, column: int, bit: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves wire from desired partial product column bit position.</p>
<p>If bit pair (AND/NAND gate) is present at the desired position, it is reduced and replaced with AND/NAND gate output wire accordingly.
Either former logic gate's output wire or present wire is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Partial product column index.</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>Bit position within the chosen column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Wire</code></dt>
<dd>Return Wire present at specified position.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_column_wire(self, column: int, bit: int):
    &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

    If bit pair (AND/NAND gate) is present at the desired position, it is reduced and replaced with AND/NAND gate output wire accordingly.
    Either former logic gate&#39;s output wire or present wire is returned.

    Args:
        column (int): Partial product column index.
        bit (int): Bit position within the chosen column.

    Returns:
        Wire: Return Wire present at specified position.
    &#34;&#34;&#34;
    # Checks if a logic gate is present at desired column bit position. If so the gate is added to circuit&#39;s list of subcomponents,
    # and the former logic gates&#39;s output bit replaces the gate at desired column bit position. This output wire is also returned to the caller.
    if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
        self.add_component(self.columns[column][bit+1])
        return self.get_previous_component(1).out
    else:
        return self.columns[column][bit+1]</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wires"><code class="name flex">
<span>def <span class="ident">add_column_wires</span></span>(<span>self, column: list, column_index: int, signed: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Fills circuit's partial product column with corresponding bit pairs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>list</code></dt>
<dd>List representing column of partial product bits.</dd>
<dt><strong><code>column_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of partial products column.</dd>
<dt><strong><code>signed</code></strong> :&ensp;<code>bool</code></dt>
<dd>Specify whether pp columns bit pairs should perform signed multiplication or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>Updated column list containing corresponding number of input bit pairs to form proper pp column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_column_wires(self, column: list, column_index: int, signed: bool):
    &#34;&#34;&#34;Fills circuit&#39;s partial product column with corresponding bit pairs.

    Args:
        column (list): List representing column of partial product bits.
        column_index (int): Index of partial products column.
        signed (bool): Specify whether pp columns bit pairs should perform signed multiplication or not.

    Returns:
        list: Updated column list containing corresponding number of input bit pairs to form proper pp column.
    &#34;&#34;&#34;
    # Adding neccessary number of lists (based on number of bits in the column – stored in `column[0]`)
    # to column that each represent individual bit pairs for described column (these bit pairs are then combined in AND/NAND gates)
    [column.append([]) for _ in range(column[0])]
    # Filling column bit pair lists with appropriate bits
    if column_index &lt;= self.N-1:
        [column[column[0]-index].append(self.a.get_wire(index)) for index in range(0, column[0])]
        [column[index+1].append(self.b.get_wire(index)) for index in range(0, column[0])]
    else:
        [column[self.a.N-index].append(self.a.get_wire(index)) for index in range(self.a.N-1, self.a.N-column[0]-1, -1)]
        [column[index-(self.a.N-1-column[0])].append(self.b.get_wire(index)) for index in range(self.a.N-column[0], self.a.N)]

    # Converting unsigned column pp bit pair lists into AND gates
    if signed is False:
        column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
    # Converting signed column pp bit pair lists into AND/NAND gates (based on Baugh-Wooley multiplication algorithm)
    else:
        # First half of partial product columns contains only AND gates
        if column_index &lt; self.N-1 or column_index == self.out.N-2:
            column[1:] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(1, len(column))]
        # Second half of partial product columns contains NAND/AND gates
        else:
            column[1] = NandGate(a=column[1][0], b=column[1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[1][0].index)+&#39;_&#39;+str(column[1][1].index), parent_component=self)
            column[-1] = NandGate(a=column[-1][0], b=column[-1][1], prefix=self.prefix+&#39;_nand_&#39;+str(column[-1][0].index)+&#39;_&#39;+str(column[-1][1].index), parent_component=self)
            if len(column[2:-1]) != 0:
                column[2:-1] = [AndGate(a=column[i][0], b=column[i][1], prefix=self.prefix+&#39;_and_&#39;+str(column[i][0].index)+&#39;_&#39;+str(column[i][1].index), parent_component=self) for i in range(2, len(column)-1)]

    return column</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_height"><code class="name flex">
<span>def <span class="ident">get_column_height</span></span>(<span>self, column_num: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the current height of desired partial products column.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column_num</code></strong> :&ensp;<code>int</code></dt>
<dd>Index of pp column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Height of the current bit column.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_height(self, column_num: int):
    &#34;&#34;&#34;Retrieves the current height of desired partial products column.

    Args:
        column_num (int): Index of pp column.

    Returns:
        int: Height of the current bit column.
    &#34;&#34;&#34;
    return self.columns[column_num][0]</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_wire"><code class="name flex">
<span>def <span class="ident">get_column_wire</span></span>(<span>self, column: int, bit: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves wire from desired partial product column bit position.</p>
<p>If bit pair (AND/NAND gate) is present at the desired position, AND/NAND gate output wire is returned,
if not the wire present at the desired position is returned.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>int</code></dt>
<dd>Partial product column index.</dd>
<dt><strong><code>bit</code></strong> :&ensp;<code>int</code></dt>
<dd>Bit position within the chosen column.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Wire</code></dt>
<dd>Return Wire present at specified position.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_column_wire(self, column: int, bit: int):
    &#34;&#34;&#34;Retrieves wire from desired partial product column bit position.

    If bit pair (AND/NAND gate) is present at the desired position, AND/NAND gate output wire is returned,
    if not the wire present at the desired position is returned.

    Args:
        column (int): Partial product column index.
        bit (int): Bit position within the chosen column.

    Returns:
        Wire: Return Wire present at specified position.
    &#34;&#34;&#34;
    # Checks if a logic gate is present at desired column bit position. If so, its output bit is returned.
    if isinstance(self.columns[column][bit+1], AndGate) or isinstance(self.columns[column][bit+1], NandGate):
        return self.columns[column][bit+1].out
    else:
        return self.columns[column][bit+1]</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_previous_partial_product"><code class="name flex">
<span>def <span class="ident">get_previous_partial_product</span></span>(<span>self, a_index: int, b_index: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Used in array multipliers to get previous row's component output wires for further connection to another component's input.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>a_index</code></strong> :&ensp;<code>int</code></dt>
<dd>First input wire index.</dd>
<dt><strong><code>b_index</code></strong> :&ensp;<code>int</code></dt>
<dd>Second input wire index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Wire</code></dt>
<dd>Previous row's component wire of corresponding pp.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_previous_partial_product(self, a_index: int, b_index: int):
    &#34;&#34;&#34;Used in array multipliers to get previous row&#39;s component output wires for further connection to another component&#39;s input.

    Args:
        a_index (int): First input wire index.
        b_index (int): Second input wire index.

    Returns:
        Wire: Previous row&#39;s component wire of corresponding pp.
    &#34;&#34;&#34;
    # To get the index of previous row&#39;s connecting adder and its generated pp
    index = ((b_index-2) * (self.N*2)) + ((self.N-1)+2*(a_index+2))

    # Get carry wire as input for the last adder in current row
    if a_index == self.N-1:
        index = index-2
        return self.components[index].get_carry_wire()
    # Get sum wire as input for current adder
    else:
        return self.components[index].get_sum_wire()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.init_column_heights"><code class="name flex">
<span>def <span class="ident">init_column_heights</span></span>(<span>self, signed: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates appropriate number of partial product columns along with filling them with corresponding number of bit pairs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signed</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Specify whether pp columns bit pairs should perform signed multiplication or not. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of partial product columns with their bit pairs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_column_heights(self, signed: bool = False):
    &#34;&#34;&#34;Creates appropriate number of partial product columns along with filling them with corresponding number of bit pairs.

    Args:
        signed (bool, optional): Specify whether pp columns bit pairs should perform signed multiplication or not. Defaults to False.

    Returns:
        list: List of partial product columns with their bit pairs.
    &#34;&#34;&#34;
    columns = [[num] if num &lt;= self.N else [num - (num - self.N)*2] for num in range(1, self.out.N)]
    columns = [self.add_column_wires(column=col, column_index=columns.index(col), signed=signed) for col in columns]
    return columns</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_heights"><code class="name flex">
<span>def <span class="ident">update_column_heights</span></span>(<span>self, curr_column: int, curr_height_change: int, next_column: int = 0, next_height_change: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates height of desired column and optionally also its subsequent column.</p>
<p>Used within dadda and wallace multipliers to perform gradual reduction of partial product columns through the stages.
Allows to choose the height change to take effect on the chosen column index and optionally also the same for the following
column if it should also be affected.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curr_column</code></strong> :&ensp;<code>int</code></dt>
<dd>Current pp column index.</dd>
<dt><strong><code>curr_height_change</code></strong> :&ensp;<code>int</code></dt>
<dd>Height change for the chosen current pp column.</dd>
<dt><strong><code>next_column</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Subsequent pp column index. Defaults to 0.</dd>
<dt><strong><code>next_height_change</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Height change for the chosen subsequent pp column. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_column_heights(self, curr_column: int, curr_height_change: int, next_column: int = 0, next_height_change: int = 0):
    &#34;&#34;&#34;Updates height of desired column and optionally also its subsequent column.

    Used within dadda and wallace multipliers to perform gradual reduction of partial product columns through the stages.
    Allows to choose the height change to take effect on the chosen column index and optionally also the same for the following
    column if it should also be affected.

    Args:
        curr_column (int): Current pp column index.
        curr_height_change (int): Height change for the chosen current pp column.
        next_column (int, optional): Subsequent pp column index. Defaults to 0.
        next_height_change (int, optional): Height change for the chosen subsequent pp column. Defaults to 0.
    &#34;&#34;&#34;
    self.columns[curr_column][0] = self.get_column_height(curr_column)+curr_height_change
    if next_column-1 == curr_column:
        self.columns[next_column][0] = self.get_column_height(next_column)+next_height_change</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_wires"><code class="name flex">
<span>def <span class="ident">update_column_wires</span></span>(<span>self, curr_column: int, adder: <a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit">ArithmeticCircuit</a>, next_column: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides bit height reduction of the chosen column.</p>
<p>Inserts chosen column's top bits into an <code>adder</code> circuit to reduce its bit height.
Generated sum is stored to the bottom of the column and generated carry bit is stored to the top of the next column.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>curr_column</code></strong> :&ensp;<code>int</code></dt>
<dd>Current pp column index.</dd>
<dt><strong><code>adder</code></strong> :&ensp;<code>ArithmeticCircuit</code></dt>
<dd>Two/three input one bit adder.</dd>
<dt><strong><code>next_column</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Subsequent pp column index. Defaults to 0.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_column_wires(self, curr_column: int, adder: ArithmeticCircuit, next_column: int = 0):
    &#34;&#34;&#34;Provides bit height reduction of the chosen column.

    Inserts chosen column&#39;s top bits into an `adder` circuit to reduce its bit height.
    Generated sum is stored to the bottom of the column and generated carry bit is stored to the top of the next column.

    Args:
        curr_column (int): Current pp column index.
        adder (ArithmeticCircuit): Two/three input one bit adder.
        next_column (int, optional): Subsequent pp column index. Defaults to 0.
    &#34;&#34;&#34;
    if hasattr(adder, &#34;c&#34;):
        self.columns[curr_column].pop(1)
        self.columns[curr_column].pop(1)
        self.columns[curr_column].pop(1)
        self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())
    else:
        self.columns[curr_column].pop(1)
        self.columns[curr_column].pop(1)
        self.columns[curr_column].insert(self.get_column_height(curr_column), adder.get_sum_wire())

    if next_column-1 == curr_column:
        self.columns[next_column].insert(1, adder.get_carry_wire())</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit">ArithmeticCircuit</a></b></code>:
<ul class="hlist">
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.add_component" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.add_component">add_component</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_blif_code_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_blif_code_flat">get_blif_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_blif_code_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_blif_code_hier">get_blif_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_c_code_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_c_code_flat">get_c_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_c_code_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_c_code_hier">get_c_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_carry_wire" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_carry_wire">get_carry_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_cgp_code_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_cgp_code_flat">get_cgp_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_cgp_wires" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_cgp_wires">get_cgp_wires</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_blif">get_circuit_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_c">get_circuit_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_gates" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_gates">get_circuit_gates</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_v" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_v">get_circuit_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_wire_index" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_circuit_wire_index">get_circuit_wire_index</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_component_types" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_component_types">get_component_types</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_blif">get_declaration_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_c_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_c_flat">get_declaration_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_c_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_c_hier">get_declaration_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_v_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_v_flat">get_declaration_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_v_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declaration_v_hier">get_declaration_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declarations_c_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declarations_c_hier">get_declarations_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declarations_v_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_declarations_v_hier">get_declarations_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blif_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blif_flat">get_function_blif_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_blif">get_function_block_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_c">get_function_block_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_v" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_block_v">get_function_block_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_blif">get_function_blocks_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_c">get_function_blocks_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_v" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_blocks_v">get_function_blocks_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_blif">get_function_out_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_c_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_c_flat">get_function_out_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_c_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_c_hier">get_function_out_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_v_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_v_flat">get_function_out_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_v_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_function_out_v_hier">get_function_out_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_includes_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_includes_c">get_includes_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_c_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_c_flat">get_init_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_c_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_c_hier">get_init_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_v_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_v_flat">get_init_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_v_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_init_v_hier">get_init_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_instance_num" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_instance_num">get_instance_num</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_invocation_blif_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_invocation_blif_hier">get_invocation_blif_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_invocations_blif_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_invocations_blif_hier">get_invocations_blif_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_multi_bit_components" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_multi_bit_components">get_multi_bit_components</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_one_bit_components" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_one_bit_components">get_one_bit_components</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_out_invocation_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_out_invocation_c">get_out_invocation_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_out_invocation_v" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_out_invocation_v">get_out_invocation_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_outputs_cgp" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_outputs_cgp">get_outputs_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_parameters_cgp" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_parameters_cgp">get_parameters_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_previous_component" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_previous_component">get_previous_component</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_blif" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_blif">get_prototype_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_c" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_c">get_prototype_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_v" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_prototype_v">get_prototype_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_sum_wire" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_sum_wire">get_sum_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_triplets_cgp" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_triplets_cgp">get_triplets_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_unique_types" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_unique_types">get_unique_types</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_v_code_flat" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_v_code_flat">get_v_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_v_code_hier" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.get_v_code_hier">get_v_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.save_wire_id" href="arithmetic_circuit.html#ariths_gen.core.arithmetic_circuits.arithmetic_circuit.ArithmeticCircuit.save_wire_id">save_wire_id</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ariths_gen.core.arithmetic_circuits" href="index.html">ariths_gen.core.arithmetic_circuits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit">MultiplierCircuit</a></code></h4>
<ul class="">
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wire" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wire">add_column_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wires" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.add_column_wires">add_column_wires</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_height" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_height">get_column_height</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_wire" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_column_wire">get_column_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_maximum_height" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_maximum_height">get_maximum_height</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_previous_partial_product" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.get_previous_partial_product">get_previous_partial_product</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.init_column_heights" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.init_column_heights">init_column_heights</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_heights" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_heights">update_column_heights</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_wires" href="#ariths_gen.core.arithmetic_circuits.multiplier_circuit.MultiplierCircuit.update_column_wires">update_column_wires</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>