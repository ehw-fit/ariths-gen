<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ariths_gen.core.arithmetic_circuits.general_circuit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ariths_gen.core.arithmetic_circuits.general_circuit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ariths_gen.core.logic_gate_circuits.logic_gate_circuit import OneInputLogicGate, TwoInputLogicGate

from ariths_gen.wire_components import (
    Wire,
    ConstantWireValue0,
    ConstantWireValue1,
    Bus
)


class GeneralCircuit():
    &#34;&#34;&#34;Class represents a general arithmetic circuit and ensures their generation to various representations.

    The __init__ method fills some mandatory attributes concerning arithmetic circuit
    that are later used for generation into various representations.
    &#34;&#34;&#34;

    def __init__(self, prefix: str, name: str, out_N: int, inner_component: bool = False, inputs: list=[]):
        if prefix == &#34;&#34;:
            self.prefix = name
        else:
            self.prefix = prefix + &#34;_&#34; + name
        self.inner_component = inner_component
        self.inputs = inputs
        self.out = Bus(self.prefix+&#34;_out&#34;, out_N, out_bus=True)

        self.components = []
        self.circuit_wires = []
        self.circuit_gates = []
        self.c_data_type = &#34;uint64_t&#34;

    def add_component(self, component):
        &#34;&#34;&#34;Adds a component into list of circuit&#39;s inner subcomponents.

        Args:
            component: Subcomponent to be added into list of components composing described circuit.
        &#34;&#34;&#34;
        self.components.append(component)
        return component

    def get_previous_component(self, number: int = 1):
        &#34;&#34;&#34;Retrieves previously added composite subcomponent from circuit&#39;s list of components.

        Args:
            number (int, optional): Offset indicating which lastly added component will be retrieved. Defaults to 1.

        Returns:
            component: Desired previously added composite component.
        &#34;&#34;&#34;
        return self.components[-number]

    def get_instance_num(self, cls, count_disabled_gates: bool = True):
        &#34;&#34;&#34;Informs how many instances of the same type are already present inside circuit&#39;s components list.

        Args:
            cls (type): Class type for which to count the number of instances in the components list.
            count_disabled_gates (bool, optional): Indicates whether logic gates that aren&#39;t generated should be also counted. Defaults to True.
        Returns:
            int: Number of instances of the same class type.
        &#34;&#34;&#34;
        if issubclass(cls, TwoInputLogicGate) and count_disabled_gates is False:
            return sum(isinstance(c, cls) for c in self.components if isinstance(c, cls) and c.disable_generation is False)
        else:
            return sum(isinstance(c, cls) for c in self.components)

    def get_circuit_gates(self):
        &#34;&#34;&#34;Gets a list of all the logic gates in circuit that should be generated.

        Returns:
            list: List of composite logic gates.
        &#34;&#34;&#34;
        gates = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                if c.disable_generation is False:
                    gates.append(c)
            else:
                gates.extend((c.get_circuit_gates()))
        return gates

    def get_one_bit_components(self):
        &#34;&#34;&#34;Retrieves a list of all the one bit circuits (besides logic gates) present as subcomponents inside the circuit.

        Returns:
            list: List of composite one bit circuits.
        &#34;&#34;&#34;
        one_bit_comps = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                continue
            elif isinstance(getattr(c, &#39;a&#39;), Wire):
                one_bit_comps.append(c)
            else:
                one_bit_comps.extend(c.get_one_bit_components())

        return one_bit_comps

    def get_multi_bit_components(self):
        &#34;&#34;&#34;Retrieves a list of all the multi bit circuits present as subcomponents inside the circuit.

        Returns:
            list: List of composite multi bit circuits.
        &#34;&#34;&#34;
        multi_bit_comps = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                continue
            elif isinstance(getattr(c, &#39;a&#39;), Wire):
                continue
            else:
                multi_bit_comps.append(c)
        return multi_bit_comps

    @staticmethod
    def get_unique_types(components: list):
        &#34;&#34;&#34;Retrieves just the unique representatives of class types present inside the provided components list.

        Args:
            components (list): List of components to be filtered.

        Returns:
            list: List of unique composite class types.
        &#34;&#34;&#34;
        return list({type(c): c for c in components}.values())

    def get_component_types(self):
        &#34;&#34;&#34;Retrieves a list of all the unique types of subcomponents composing the circuit.

        Returning list consists of only the unique types of logic gates, one bit circuits and multi bit circuits.

        Returns:
            list: List of unique component types describing the circuit.
        &#34;&#34;&#34;
        gate_comps = self.get_unique_types(components=self.get_circuit_gates())
        one_bit_comps = self.get_unique_types(
            components=self.get_one_bit_components())
        multi_bit_comps = self.get_unique_types(
            components=self.get_multi_bit_components())

        all_components = gate_comps + one_bit_comps + multi_bit_comps
        return all_components

    def get_sum_wire(self):
        &#34;&#34;&#34;Get output wire carrying sum value.

        Returns:
           Wire: Return sum wire.
        &#34;&#34;&#34;
        return self.out.get_wire(0)

    def get_carry_wire(self):
        &#34;&#34;&#34;Get output wire carrying carry out value.

        Returns:
           Wire: Return carry out wire.
        &#34;&#34;&#34;
        return self.out.get_wire(1)

    def save_wire_id(self, wire: Wire):
        &#34;&#34;&#34;Returns appropriate wire index position within the circuit.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.

        Args:
            wire (Wire): Wire that will be stored at this circuit index position.

        Returns:
            int: Wire&#39;s index position within circuit.
        &#34;&#34;&#34;
        if wire.is_const():
            return wire.cgp_const
        else:
            return len([w[0] for w in self.circuit_wires if w[0].is_const() is False]) + 2

    def get_cgp_wires(self):
        &#34;&#34;&#34;Gets a list of all wires in circuit along with their index position for cgp chromosome generation and stores them inside `self.circuit_wires` list.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.
        &#34;&#34;&#34;
        self.circuit_wires = []
        if isinstance(self.a, Bus):
            [self.circuit_wires.append(
                (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.a.bus]
            [self.circuit_wires.append(
                (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.b.bus]
        else:
            self.circuit_wires.append(
                (self.a, f&#34;{self.a.name}&#34;, self.save_wire_id(wire=self.a)))
            self.circuit_wires.append(
                (self.b, f&#34;{self.b.name}&#34;, self.save_wire_id(wire=self.b)))
            if hasattr(self, &#39;c&#39;):
                self.circuit_wires.append(
                    (self.c, f&#34;{self.c.name}&#34;, self.save_wire_id(wire=self.c)))

        for gate in self.circuit_gates:
            if not [item for item in self.circuit_wires if gate.a.name == item[1]]:
                self.circuit_wires.append(
                    (gate.a, gate.a.name, self.save_wire_id(wire=gate.a)))

            if hasattr(gate, &#39;b&#39;) and not [item for item in self.circuit_wires if gate.b.name == item[1]]:
                self.circuit_wires.append(
                    (gate.b, gate.b.name, self.save_wire_id(wire=gate.b)))

            if not [item for item in self.circuit_wires if gate.out.name == item[1]]:
                self.circuit_wires.append(
                    (gate.out, gate.out.name, self.save_wire_id(wire=gate.out)))

    def get_circuit_wire_index(self, wire: Wire):
        &#34;&#34;&#34;Searches for circuit&#39;s wire unique index position within the circuit. Used for cgp chromosome generation.

        Args:
            wire (Wire): Wire to retrieve index position of.

        Returns:
            int: Wire&#39;s index position number within the circuit.
        &#34;&#34;&#34;
        if wire.is_const():
            return wire.cgp_const
        else:
            for w in self.circuit_wires:
                if wire.name == w[1]:
                    return w[2]

    &#34;&#34;&#34; C CODE GENERATION &#34;&#34;&#34;
    # FLAT C #
    @staticmethod
    def get_includes_c():
        &#34;&#34;&#34;Generates necessary C library includes for output representation.

        Returns:
            str: C code library includes.
        &#34;&#34;&#34;
        return f&#34;#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n&#34;

    def get_prototype_c(self):
        &#34;&#34;&#34;Generates C code function header to describe corresponding arithmetic circuit&#39;s interface in C code.

        Returns:
            str: Function&#39;s name and parameters in C code.
        &#34;&#34;&#34;
        return f&#34;{self.c_data_type} {self.prefix}(&#34; + &#34;,&#34;.join([f&#34;{self.c_data_type} {x.prefix}&#34; for x in self.inputs]) + &#34;)&#34; + &#34;{&#34; + &#34;\n&#34;

    def get_declaration_c_flat(self):
        &#34;&#34;&#34;Generates flat C code declaration of input/output circuit wires.

        Returns:
            str: Flat C code arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;&#34;.join([c.get_declaration_c_flat() for c in self.components])

    def get_init_c_flat(self):
        &#34;&#34;&#34;Generates flat C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Flat C code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_assign_c_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_c_flat() for c in self.components])

    def get_function_out_c_flat(self):
        &#34;&#34;&#34;Generates flat C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat C code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_c_flat()

    # Generating flat C code representation of circuit
    def get_c_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat C code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_includes_c())
        file_object.write(self.get_prototype_c())
        file_object.write(self.out.get_declaration_c())
        file_object.write(self.get_declaration_c_flat()+&#34;\n&#34;)
        file_object.write(self.get_init_c_flat()+&#34;\n&#34;)
        file_object.write(self.get_function_out_c_flat())
        file_object.write(f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;)
        file_object.close()

    # HIERARCHICAL C #
    def get_function_blocks_c(self):
        &#34;&#34;&#34;Generates hierarchical C code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical C code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        self.component_types = self.get_component_types()
        return &#34;&#34;.join([c.get_function_block_c() for c in self.component_types])

    def get_function_block_c(self):
        &#34;&#34;&#34;Generates hierarchical C code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical C code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_c()}\n\n&#34;

    def get_declarations_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code declaration of input/output circuit wires.

        Returns:
            str: Hierarchical C code containing unique declaration of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_declaration_c_hier() for c in self.components])

    def get_declaration_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code declaration of corresponding subcomponent input/output wires inside the upper component.

        Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
        inside the upper component from which function block has been invoked.

        Returns:
            str: Hierarchical C code of subcomponent arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;  {self.c_data_type} {self.a.prefix} = 0;\n&#34; + \
               f&#34;  {self.c_data_type} {self.b.prefix} = 0;\n&#34; + \
               f&#34;  {self.c_data_type} {self.out.prefix} = 0;\n&#34;

    def get_init_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Hierarchical C code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_gate_invocation_c() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_c(circuit_prefix=self.prefix) for c in self.components])

    def get_out_invocation_c(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical C code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
        Assigns output values from invocation of the corresponding function block into inner wires present inside
        the upper component from which function block has been invoked.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical C code of subcomponent&#39;s C function invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type for proper C code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
        return self.a.return_bus_wires_values_c_hier() + self.b.return_bus_wires_values_c_hier() + \
            f&#34;  {self.out.prefix} = {circuit_type}({self.a.prefix}, {self.b.prefix});\n&#34;

    def get_function_out_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Hierarchical C code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_c_hier()

    def get_circuit_c(self):
        &#34;&#34;&#34;Generates hierarchical C code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical C code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_c()}&#34; + \
               f&#34;{self.out.get_declaration_c()}&#34; + \
               f&#34;{self.get_declarations_c_hier()}\n&#34; + \
               f&#34;{self.get_init_c_hier()}\n&#34; + \
               f&#34;{self.get_function_out_c_hier()}&#34; + \
               f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;

    # Generating hierarchical C code representation of circuit
    def get_c_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical C code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_includes_c())
        file_object.write(self.get_function_blocks_c())
        file_object.write(self.get_circuit_c())
        file_object.close()

    &#34;&#34;&#34; VERILOG CODE GENERATION &#34;&#34;&#34;
    # FLAT VERILOG #

    def get_prototype_v(self):
        &#34;&#34;&#34;Generates Verilog code module header to describe corresponding arithmetic circuit&#39;s interface in Verilog code.

        Returns:
            str: Module&#39;s name and parameters in Verilog code.
        &#34;&#34;&#34;
        return f&#34;module {self.prefix}(&#34; + &#34;,&#34;.join(f&#34;input [{x.N-1}:0] {x.prefix}&#34; for x in self.inputs) + f&#34;, output [{self.out.N-1}:0] {self.out.prefix});\n&#34;

    def get_declaration_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code declaration of input/output circuit wires.

        Returns:
            str: Flat Verilog code arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;&#34;.join([c.get_declaration_v_flat() for c in self.components])

    def get_init_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output buses wires.

        Returns:
            str: Flat Verilog code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_assign_v_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_v_flat() for c in self.components])

    def get_function_out_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat Verilog code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_v_flat()

    # Generating flat Verilog code representation of circuit
    def get_v_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat Verilog code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_prototype_v())
        file_object.write(self.get_declaration_v_flat()+&#34;\n&#34;)
        file_object.write(self.get_init_v_flat() + &#34;\n&#34;)
        file_object.write(self.get_function_out_v_flat())
        file_object.write(f&#34;endmodule&#34;)
        file_object.close()

    # HIERARCHICAL VERILOG #
    def get_function_blocks_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical Verilog code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        self.component_types = self.get_component_types()
        return &#34;&#34;.join([c.get_function_block_v() for c in self.component_types])

    def get_function_block_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical Verilog code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_v()}\n\n&#34;

    def get_declarations_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code declaration of input/output circuit wires.

        Returns:
            str: Hierarchical Verilog code containing unique declaration of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_declaration_v_hier() for c in self.components])

    def get_declaration_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code declaration of corresponding subcomponent input/output wires inside the upper component.

        Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
        inside the upper component from which function block has been invoked.

        Returns:
            str: Hierarchical Verilog code of subcomponent arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;  wire [{self.a.N-1}:0] {self.a.prefix};\n&#34; + \
               f&#34;  wire [{self.b.N-1}:0] {self.b.prefix};\n&#34; + \
               f&#34;  wire [{self.out.N-1}:0] {self.out.prefix};\n&#34;

    def get_init_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Hierarchical Verilog code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_gate_invocation_v() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_v(circuit_prefix=self.prefix) for c in self.components])

    def get_out_invocation_v(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical Verilog code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
        Assigns output values from invocation of the corresponding function block into inner wires present inside
        the upper component from which function block has been invoked.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical Verilog code of subcomponent&#39;s module invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type and insitu copying out bus for proper Verilog code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)

        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return self.a.return_bus_wires_values_v_hier() + self.b.return_bus_wires_values_v_hier() + \
            f&#34;  {circuit_type} {circuit_type}_{self.out.prefix}(.{circuit_block.a.prefix}({self.a.prefix}), .{circuit_block.b.prefix}({self.b.prefix}), .{circuit_block.out.prefix}({self.out.prefix}));\n&#34;

    def get_function_out_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Hierarchical Verilog code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_v_hier()

    def get_circuit_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical Verilog code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_v()}&#34; + \
               f&#34;{self.get_declarations_v_hier()}\n&#34; + \
               f&#34;{self.get_init_v_hier()}\n&#34; + \
               f&#34;{self.get_function_out_v_hier()}&#34; + \
               f&#34;endmodule&#34;

    # Generating hierarchical Verilog code representation of circuit
    def get_v_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_function_blocks_v())
        file_object.write(self.get_circuit_v())
        file_object.close()

    &#34;&#34;&#34; BLIF CODE GENERATION &#34;&#34;&#34;
    # FLAT BLIF #

    def get_prototype_blif(self):
        &#34;&#34;&#34;Generates Blif code model name of described arithmetic circuit.

        Returns:
            str: Model&#39;s name in Blif code.
        &#34;&#34;&#34;
        return f&#34;.model {self.prefix}\n&#34;

    def get_declaration_blif(self):
        &#34;&#34;&#34;Generates flat Blif code declaration of input/output circuit wires.

        Returns:
            str: Flat Blif code containing declaration of circuit&#39;s wires.
        &#34;&#34;&#34;
        if self.N == 1:
            return f&#34;.inputs {self.a.prefix} {self.b.prefix}\n&#34; + \
                   f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.names vdd\n1\n&#34; + \
                   f&#34;.names gnd\n0\n&#34;
        else:
            return f&#34;.inputs{self.a.get_wire_declaration_blif()}{self.b.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.names vdd\n1\n&#34; + \
                   f&#34;.names gnd\n0\n&#34;

    def get_function_blif_flat(self):
        &#34;&#34;&#34;Generates flat Blif code with invocation of subcomponents logic gates functions via their corresponding truth tables.

        Returns:
            str: Flat Blif code containing invocation of inner subcomponents logic gates Boolean functions.
        &#34;&#34;&#34;
        return &#34;&#34;.join(c.get_function_blif_flat() for c in self.components)

    def get_function_out_blif(self):
        &#34;&#34;&#34;Generates flat Blif code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat Blif code containing output bus wires assignment.
        &#34;&#34;&#34;
        return f&#34;{self.out.get_wire_assign_blif(output=True)}&#34;

    # Generating flat BLIF code representation of circuit
    def get_blif_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat Blif code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_prototype_blif())
        file_object.write(self.get_declaration_blif())
        file_object.write(self.get_function_blif_flat())
        file_object.write(self.get_function_out_blif())
        file_object.write(f&#34;.end\n&#34;)
        file_object.close()

    # HIERARCHICAL BLIF #
    def get_invocations_blif_hier(self):
        &#34;&#34;&#34;Generates hierarchical Blif code with invocations of subcomponents function blocks.

        Returns:
            str: Hierarchical Blif code containing invocations of inner subcomponents function blocks.
        &#34;&#34;&#34;
        return &#34;&#34;.join(c.get_invocation_blif_hier(circuit_prefix=self.prefix) for c in self.components)

    def get_invocation_blif_hier(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical Blif code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Used for multi-bit subcomponent&#39;s modul invocation.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical Blif code of subcomponent&#39;s model invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type for proper Blif code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
        return f&#34;{self.a.get_wire_assign_blif(output=True)}&#34; + \
               f&#34;{self.b.get_wire_assign_blif(output=True)}&#34; + \
               f&#34;.subckt {circuit_type}&#34; + \
               &#34;&#34;.join([f&#34; a[{self.a.bus.index(w)}]={self.a.prefix}[{self.a.bus.index(w)}]&#34; for w in self.a.bus]) + \
               &#34;&#34;.join([f&#34; b[{self.b.bus.index(w)}]={self.b.prefix}[{self.b.bus.index(w)}]&#34; for w in self.b.bus]) + \
               &#34;&#34;.join(
                   [f&#34; {circuit_type}_out[{self.out.bus.index(o)}]={o.name}&#34; for o in self.out.bus]) + &#34;\n&#34;

    def get_circuit_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical Blif code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_blif()}&#34; + \
               f&#34;{self.get_declaration_blif()}&#34; + \
               f&#34;{self.get_invocations_blif_hier()}&#34; + \
               f&#34;{self.get_function_out_blif()}&#34; + \
               f&#34;.end\n&#34;

    def get_function_blocks_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical Blif code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        # (iterating backwards as opposed to other representations so the top modul is always above its subcomponents)
        self.component_types = self.get_component_types()
        return &#34;\n&#34;.join([c.get_function_block_blif() for c in self.component_types[::-1]])

    def get_function_block_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical Blif code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_blif()}&#34;

    # Generating hierarchical BLIF code representation of circuit
    def get_blif_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_circuit_blif()+&#34;\n&#34;)
        file_object.write(self.get_function_blocks_blif())
        file_object.close()

    &#34;&#34;&#34; CGP CODE GENERATION &#34;&#34;&#34;
    # FLAT CGP #

    def get_parameters_cgp(self):
        &#34;&#34;&#34;Generates CGP chromosome parameters of corresponding arithmetic circuit.

        In total seven parameters represent: total inputs, total outputs, number of rows, number of columns (gates),
        number of each gate&#39;s inputs, number of each gate&#39;s outputs, quality constant value.

        Returns:
            str: CGP chromosome parameters of described arithmetic circuit.
        &#34;&#34;&#34;
        self.circuit_gates = self.get_circuit_gates()
        return f&#34;{{{self.a.N+self.a.N},{self.out.N},1,{len(self.circuit_gates)},2,1,0}}&#34;

    def get_triplets_cgp(self):
        &#34;&#34;&#34;Generates list of logic gate triplets (first input wire, second input wire, logic gate function) using wires unique position indexes within the described circuit.

        Each triplet represents unique logic gate within the described arithmetic circuit. Besides the contained input wires indexes and gate&#39;s inner logic function, an output wire
        with incremented index position is also created and remembered to be appropriately driven as an input to another logic gate or as the circuit&#39;s output.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.

        Returns:
            str: List of triplets each describing logic function of corresponding two input logic gate and as a whole describe the arithmetic circuit.
        &#34;&#34;&#34;
        self.get_cgp_wires()
        return &#34;&#34;.join([g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), out_id=self.get_circuit_wire_index(g.out)) if isinstance(g, OneInputLogicGate) else
                       g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), b_id=self.get_circuit_wire_index(g.b), out_id=self.get_circuit_wire_index(g.out)) for g in self.circuit_gates])

    def get_outputs_cgp(self):
        &#34;&#34;&#34;Generates list of output wires indexes of described arithmetic circuit from MSB to LSB.

        Returns:
            str: List of arithmetic circuit&#39;s output wire indexes.
        &#34;&#34;&#34;
        return &#34;(&#34; + &#34;,&#34;.join([str(self.get_circuit_wire_index(o)) for o in self.out.bus]) + &#34;)&#34;

    # Generating flat CGP chromosome representation of circuit
    def get_cgp_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat CGP chromosome representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_parameters_cgp())
        file_object.write(self.get_triplets_cgp())
        file_object.write(self.get_outputs_cgp())
        file_object.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit"><code class="flex name class">
<span>class <span class="ident">GeneralCircuit</span></span>
<span>(</span><span>prefix: str, name: str, out_N: int, inner_component: bool = False, inputs: list = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Class represents a general arithmetic circuit and ensures their generation to various representations.</p>
<p>The <strong>init</strong> method fills some mandatory attributes concerning arithmetic circuit
that are later used for generation into various representations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneralCircuit():
    &#34;&#34;&#34;Class represents a general arithmetic circuit and ensures their generation to various representations.

    The __init__ method fills some mandatory attributes concerning arithmetic circuit
    that are later used for generation into various representations.
    &#34;&#34;&#34;

    def __init__(self, prefix: str, name: str, out_N: int, inner_component: bool = False, inputs: list=[]):
        if prefix == &#34;&#34;:
            self.prefix = name
        else:
            self.prefix = prefix + &#34;_&#34; + name
        self.inner_component = inner_component
        self.inputs = inputs
        self.out = Bus(self.prefix+&#34;_out&#34;, out_N, out_bus=True)

        self.components = []
        self.circuit_wires = []
        self.circuit_gates = []
        self.c_data_type = &#34;uint64_t&#34;

    def add_component(self, component):
        &#34;&#34;&#34;Adds a component into list of circuit&#39;s inner subcomponents.

        Args:
            component: Subcomponent to be added into list of components composing described circuit.
        &#34;&#34;&#34;
        self.components.append(component)
        return component

    def get_previous_component(self, number: int = 1):
        &#34;&#34;&#34;Retrieves previously added composite subcomponent from circuit&#39;s list of components.

        Args:
            number (int, optional): Offset indicating which lastly added component will be retrieved. Defaults to 1.

        Returns:
            component: Desired previously added composite component.
        &#34;&#34;&#34;
        return self.components[-number]

    def get_instance_num(self, cls, count_disabled_gates: bool = True):
        &#34;&#34;&#34;Informs how many instances of the same type are already present inside circuit&#39;s components list.

        Args:
            cls (type): Class type for which to count the number of instances in the components list.
            count_disabled_gates (bool, optional): Indicates whether logic gates that aren&#39;t generated should be also counted. Defaults to True.
        Returns:
            int: Number of instances of the same class type.
        &#34;&#34;&#34;
        if issubclass(cls, TwoInputLogicGate) and count_disabled_gates is False:
            return sum(isinstance(c, cls) for c in self.components if isinstance(c, cls) and c.disable_generation is False)
        else:
            return sum(isinstance(c, cls) for c in self.components)

    def get_circuit_gates(self):
        &#34;&#34;&#34;Gets a list of all the logic gates in circuit that should be generated.

        Returns:
            list: List of composite logic gates.
        &#34;&#34;&#34;
        gates = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                if c.disable_generation is False:
                    gates.append(c)
            else:
                gates.extend((c.get_circuit_gates()))
        return gates

    def get_one_bit_components(self):
        &#34;&#34;&#34;Retrieves a list of all the one bit circuits (besides logic gates) present as subcomponents inside the circuit.

        Returns:
            list: List of composite one bit circuits.
        &#34;&#34;&#34;
        one_bit_comps = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                continue
            elif isinstance(getattr(c, &#39;a&#39;), Wire):
                one_bit_comps.append(c)
            else:
                one_bit_comps.extend(c.get_one_bit_components())

        return one_bit_comps

    def get_multi_bit_components(self):
        &#34;&#34;&#34;Retrieves a list of all the multi bit circuits present as subcomponents inside the circuit.

        Returns:
            list: List of composite multi bit circuits.
        &#34;&#34;&#34;
        multi_bit_comps = []
        for c in self.components:
            if isinstance(c, TwoInputLogicGate):
                continue
            elif isinstance(getattr(c, &#39;a&#39;), Wire):
                continue
            else:
                multi_bit_comps.append(c)
        return multi_bit_comps

    @staticmethod
    def get_unique_types(components: list):
        &#34;&#34;&#34;Retrieves just the unique representatives of class types present inside the provided components list.

        Args:
            components (list): List of components to be filtered.

        Returns:
            list: List of unique composite class types.
        &#34;&#34;&#34;
        return list({type(c): c for c in components}.values())

    def get_component_types(self):
        &#34;&#34;&#34;Retrieves a list of all the unique types of subcomponents composing the circuit.

        Returning list consists of only the unique types of logic gates, one bit circuits and multi bit circuits.

        Returns:
            list: List of unique component types describing the circuit.
        &#34;&#34;&#34;
        gate_comps = self.get_unique_types(components=self.get_circuit_gates())
        one_bit_comps = self.get_unique_types(
            components=self.get_one_bit_components())
        multi_bit_comps = self.get_unique_types(
            components=self.get_multi_bit_components())

        all_components = gate_comps + one_bit_comps + multi_bit_comps
        return all_components

    def get_sum_wire(self):
        &#34;&#34;&#34;Get output wire carrying sum value.

        Returns:
           Wire: Return sum wire.
        &#34;&#34;&#34;
        return self.out.get_wire(0)

    def get_carry_wire(self):
        &#34;&#34;&#34;Get output wire carrying carry out value.

        Returns:
           Wire: Return carry out wire.
        &#34;&#34;&#34;
        return self.out.get_wire(1)

    def save_wire_id(self, wire: Wire):
        &#34;&#34;&#34;Returns appropriate wire index position within the circuit.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.

        Args:
            wire (Wire): Wire that will be stored at this circuit index position.

        Returns:
            int: Wire&#39;s index position within circuit.
        &#34;&#34;&#34;
        if wire.is_const():
            return wire.cgp_const
        else:
            return len([w[0] for w in self.circuit_wires if w[0].is_const() is False]) + 2

    def get_cgp_wires(self):
        &#34;&#34;&#34;Gets a list of all wires in circuit along with their index position for cgp chromosome generation and stores them inside `self.circuit_wires` list.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.
        &#34;&#34;&#34;
        self.circuit_wires = []
        if isinstance(self.a, Bus):
            [self.circuit_wires.append(
                (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.a.bus]
            [self.circuit_wires.append(
                (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.b.bus]
        else:
            self.circuit_wires.append(
                (self.a, f&#34;{self.a.name}&#34;, self.save_wire_id(wire=self.a)))
            self.circuit_wires.append(
                (self.b, f&#34;{self.b.name}&#34;, self.save_wire_id(wire=self.b)))
            if hasattr(self, &#39;c&#39;):
                self.circuit_wires.append(
                    (self.c, f&#34;{self.c.name}&#34;, self.save_wire_id(wire=self.c)))

        for gate in self.circuit_gates:
            if not [item for item in self.circuit_wires if gate.a.name == item[1]]:
                self.circuit_wires.append(
                    (gate.a, gate.a.name, self.save_wire_id(wire=gate.a)))

            if hasattr(gate, &#39;b&#39;) and not [item for item in self.circuit_wires if gate.b.name == item[1]]:
                self.circuit_wires.append(
                    (gate.b, gate.b.name, self.save_wire_id(wire=gate.b)))

            if not [item for item in self.circuit_wires if gate.out.name == item[1]]:
                self.circuit_wires.append(
                    (gate.out, gate.out.name, self.save_wire_id(wire=gate.out)))

    def get_circuit_wire_index(self, wire: Wire):
        &#34;&#34;&#34;Searches for circuit&#39;s wire unique index position within the circuit. Used for cgp chromosome generation.

        Args:
            wire (Wire): Wire to retrieve index position of.

        Returns:
            int: Wire&#39;s index position number within the circuit.
        &#34;&#34;&#34;
        if wire.is_const():
            return wire.cgp_const
        else:
            for w in self.circuit_wires:
                if wire.name == w[1]:
                    return w[2]

    &#34;&#34;&#34; C CODE GENERATION &#34;&#34;&#34;
    # FLAT C #
    @staticmethod
    def get_includes_c():
        &#34;&#34;&#34;Generates necessary C library includes for output representation.

        Returns:
            str: C code library includes.
        &#34;&#34;&#34;
        return f&#34;#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n&#34;

    def get_prototype_c(self):
        &#34;&#34;&#34;Generates C code function header to describe corresponding arithmetic circuit&#39;s interface in C code.

        Returns:
            str: Function&#39;s name and parameters in C code.
        &#34;&#34;&#34;
        return f&#34;{self.c_data_type} {self.prefix}(&#34; + &#34;,&#34;.join([f&#34;{self.c_data_type} {x.prefix}&#34; for x in self.inputs]) + &#34;)&#34; + &#34;{&#34; + &#34;\n&#34;

    def get_declaration_c_flat(self):
        &#34;&#34;&#34;Generates flat C code declaration of input/output circuit wires.

        Returns:
            str: Flat C code arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;&#34;.join([c.get_declaration_c_flat() for c in self.components])

    def get_init_c_flat(self):
        &#34;&#34;&#34;Generates flat C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Flat C code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_assign_c_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_c_flat() for c in self.components])

    def get_function_out_c_flat(self):
        &#34;&#34;&#34;Generates flat C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat C code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_c_flat()

    # Generating flat C code representation of circuit
    def get_c_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat C code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_includes_c())
        file_object.write(self.get_prototype_c())
        file_object.write(self.out.get_declaration_c())
        file_object.write(self.get_declaration_c_flat()+&#34;\n&#34;)
        file_object.write(self.get_init_c_flat()+&#34;\n&#34;)
        file_object.write(self.get_function_out_c_flat())
        file_object.write(f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;)
        file_object.close()

    # HIERARCHICAL C #
    def get_function_blocks_c(self):
        &#34;&#34;&#34;Generates hierarchical C code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical C code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        self.component_types = self.get_component_types()
        return &#34;&#34;.join([c.get_function_block_c() for c in self.component_types])

    def get_function_block_c(self):
        &#34;&#34;&#34;Generates hierarchical C code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical C code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_c()}\n\n&#34;

    def get_declarations_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code declaration of input/output circuit wires.

        Returns:
            str: Hierarchical C code containing unique declaration of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_declaration_c_hier() for c in self.components])

    def get_declaration_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code declaration of corresponding subcomponent input/output wires inside the upper component.

        Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
        inside the upper component from which function block has been invoked.

        Returns:
            str: Hierarchical C code of subcomponent arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;  {self.c_data_type} {self.a.prefix} = 0;\n&#34; + \
               f&#34;  {self.c_data_type} {self.b.prefix} = 0;\n&#34; + \
               f&#34;  {self.c_data_type} {self.out.prefix} = 0;\n&#34;

    def get_init_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Hierarchical C code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_gate_invocation_c() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_c(circuit_prefix=self.prefix) for c in self.components])

    def get_out_invocation_c(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical C code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
        Assigns output values from invocation of the corresponding function block into inner wires present inside
        the upper component from which function block has been invoked.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical C code of subcomponent&#39;s C function invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type for proper C code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
        return self.a.return_bus_wires_values_c_hier() + self.b.return_bus_wires_values_c_hier() + \
            f&#34;  {self.out.prefix} = {circuit_type}({self.a.prefix}, {self.b.prefix});\n&#34;

    def get_function_out_c_hier(self):
        &#34;&#34;&#34;Generates hierarchical C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Hierarchical C code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_c_hier()

    def get_circuit_c(self):
        &#34;&#34;&#34;Generates hierarchical C code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical C code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_c()}&#34; + \
               f&#34;{self.out.get_declaration_c()}&#34; + \
               f&#34;{self.get_declarations_c_hier()}\n&#34; + \
               f&#34;{self.get_init_c_hier()}\n&#34; + \
               f&#34;{self.get_function_out_c_hier()}&#34; + \
               f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;

    # Generating hierarchical C code representation of circuit
    def get_c_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical C code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_includes_c())
        file_object.write(self.get_function_blocks_c())
        file_object.write(self.get_circuit_c())
        file_object.close()

    &#34;&#34;&#34; VERILOG CODE GENERATION &#34;&#34;&#34;
    # FLAT VERILOG #

    def get_prototype_v(self):
        &#34;&#34;&#34;Generates Verilog code module header to describe corresponding arithmetic circuit&#39;s interface in Verilog code.

        Returns:
            str: Module&#39;s name and parameters in Verilog code.
        &#34;&#34;&#34;
        return f&#34;module {self.prefix}(&#34; + &#34;,&#34;.join(f&#34;input [{x.N-1}:0] {x.prefix}&#34; for x in self.inputs) + f&#34;, output [{self.out.N-1}:0] {self.out.prefix});\n&#34;

    def get_declaration_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code declaration of input/output circuit wires.

        Returns:
            str: Flat Verilog code arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;&#34;.join([c.get_declaration_v_flat() for c in self.components])

    def get_init_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output buses wires.

        Returns:
            str: Flat Verilog code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_assign_v_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_v_flat() for c in self.components])

    def get_function_out_v_flat(self):
        &#34;&#34;&#34;Generates flat Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat Verilog code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_v_flat()

    # Generating flat Verilog code representation of circuit
    def get_v_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat Verilog code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_prototype_v())
        file_object.write(self.get_declaration_v_flat()+&#34;\n&#34;)
        file_object.write(self.get_init_v_flat() + &#34;\n&#34;)
        file_object.write(self.get_function_out_v_flat())
        file_object.write(f&#34;endmodule&#34;)
        file_object.close()

    # HIERARCHICAL VERILOG #
    def get_function_blocks_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical Verilog code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        self.component_types = self.get_component_types()
        return &#34;&#34;.join([c.get_function_block_v() for c in self.component_types])

    def get_function_block_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical Verilog code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_v()}\n\n&#34;

    def get_declarations_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code declaration of input/output circuit wires.

        Returns:
            str: Hierarchical Verilog code containing unique declaration of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_declaration_v_hier() for c in self.components])

    def get_declaration_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code declaration of corresponding subcomponent input/output wires inside the upper component.

        Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
        inside the upper component from which function block has been invoked.

        Returns:
            str: Hierarchical Verilog code of subcomponent arithmetic circuit&#39;s wires declaration.
        &#34;&#34;&#34;
        return f&#34;  wire [{self.a.N-1}:0] {self.a.prefix};\n&#34; + \
               f&#34;  wire [{self.b.N-1}:0] {self.b.prefix};\n&#34; + \
               f&#34;  wire [{self.out.N-1}:0] {self.out.prefix};\n&#34;

    def get_init_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

        Returns:
            str: Hierarchical Verilog code initialization of arithmetic circuit wires.
        &#34;&#34;&#34;
        return &#34;&#34;.join([c.get_gate_invocation_v() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_v(circuit_prefix=self.prefix) for c in self.components])

    def get_out_invocation_v(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical Verilog code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
        Assigns output values from invocation of the corresponding function block into inner wires present inside
        the upper component from which function block has been invoked.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical Verilog code of subcomponent&#39;s module invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type and insitu copying out bus for proper Verilog code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)

        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return self.a.return_bus_wires_values_v_hier() + self.b.return_bus_wires_values_v_hier() + \
            f&#34;  {circuit_type} {circuit_type}_{self.out.prefix}(.{circuit_block.a.prefix}({self.a.prefix}), .{circuit_block.b.prefix}({self.b.prefix}), .{circuit_block.out.prefix}({self.out.prefix}));\n&#34;

    def get_function_out_v_hier(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Hierarchical Verilog code containing output bus wires assignment.
        &#34;&#34;&#34;
        return self.out.return_bus_wires_values_v_hier()

    def get_circuit_v(self):
        &#34;&#34;&#34;Generates hierarchical Verilog code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical Verilog code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_v()}&#34; + \
               f&#34;{self.get_declarations_v_hier()}\n&#34; + \
               f&#34;{self.get_init_v_hier()}\n&#34; + \
               f&#34;{self.get_function_out_v_hier()}&#34; + \
               f&#34;endmodule&#34;

    # Generating hierarchical Verilog code representation of circuit
    def get_v_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_function_blocks_v())
        file_object.write(self.get_circuit_v())
        file_object.close()

    &#34;&#34;&#34; BLIF CODE GENERATION &#34;&#34;&#34;
    # FLAT BLIF #

    def get_prototype_blif(self):
        &#34;&#34;&#34;Generates Blif code model name of described arithmetic circuit.

        Returns:
            str: Model&#39;s name in Blif code.
        &#34;&#34;&#34;
        return f&#34;.model {self.prefix}\n&#34;

    def get_declaration_blif(self):
        &#34;&#34;&#34;Generates flat Blif code declaration of input/output circuit wires.

        Returns:
            str: Flat Blif code containing declaration of circuit&#39;s wires.
        &#34;&#34;&#34;
        if self.N == 1:
            return f&#34;.inputs {self.a.prefix} {self.b.prefix}\n&#34; + \
                   f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.names vdd\n1\n&#34; + \
                   f&#34;.names gnd\n0\n&#34;
        else:
            return f&#34;.inputs{self.a.get_wire_declaration_blif()}{self.b.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
                   f&#34;.names vdd\n1\n&#34; + \
                   f&#34;.names gnd\n0\n&#34;

    def get_function_blif_flat(self):
        &#34;&#34;&#34;Generates flat Blif code with invocation of subcomponents logic gates functions via their corresponding truth tables.

        Returns:
            str: Flat Blif code containing invocation of inner subcomponents logic gates Boolean functions.
        &#34;&#34;&#34;
        return &#34;&#34;.join(c.get_function_blif_flat() for c in self.components)

    def get_function_out_blif(self):
        &#34;&#34;&#34;Generates flat Blif code assignment of corresponding arithmetic circuit&#39;s output bus wires.

        Returns:
            str: Flat Blif code containing output bus wires assignment.
        &#34;&#34;&#34;
        return f&#34;{self.out.get_wire_assign_blif(output=True)}&#34;

    # Generating flat BLIF code representation of circuit
    def get_blif_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat Blif code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_prototype_blif())
        file_object.write(self.get_declaration_blif())
        file_object.write(self.get_function_blif_flat())
        file_object.write(self.get_function_out_blif())
        file_object.write(f&#34;.end\n&#34;)
        file_object.close()

    # HIERARCHICAL BLIF #
    def get_invocations_blif_hier(self):
        &#34;&#34;&#34;Generates hierarchical Blif code with invocations of subcomponents function blocks.

        Returns:
            str: Hierarchical Blif code containing invocations of inner subcomponents function blocks.
        &#34;&#34;&#34;
        return &#34;&#34;.join(c.get_invocation_blif_hier(circuit_prefix=self.prefix) for c in self.components)

    def get_invocation_blif_hier(self, circuit_prefix: str):
        &#34;&#34;&#34;Generates hierarchical Blif code invocation of corresponding arithmetic circuit&#39;s generated function block.

        Used for multi-bit subcomponent&#39;s modul invocation.

        Args:
            circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

        Returns:
            str: Hierarchical Blif code of subcomponent&#39;s model invocation and output assignment.
        &#34;&#34;&#34;
        # Getting name of circuit type for proper Blif code generation without affecting actual generated composition
        circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
        return f&#34;{self.a.get_wire_assign_blif(output=True)}&#34; + \
               f&#34;{self.b.get_wire_assign_blif(output=True)}&#34; + \
               f&#34;.subckt {circuit_type}&#34; + \
               &#34;&#34;.join([f&#34; a[{self.a.bus.index(w)}]={self.a.prefix}[{self.a.bus.index(w)}]&#34; for w in self.a.bus]) + \
               &#34;&#34;.join([f&#34; b[{self.b.bus.index(w)}]={self.b.prefix}[{self.b.bus.index(w)}]&#34; for w in self.b.bus]) + \
               &#34;&#34;.join(
                   [f&#34; {circuit_type}_out[{self.out.bus.index(o)}]={o.name}&#34; for o in self.out.bus]) + &#34;\n&#34;

    def get_circuit_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code subcomponent&#39;s function block.

        Returns:
            str: Hierarchical Blif code of subcomponent&#39;s function block.
        &#34;&#34;&#34;
        return f&#34;{self.get_prototype_blif()}&#34; + \
               f&#34;{self.get_declaration_blif()}&#34; + \
               f&#34;{self.get_invocations_blif_hier()}&#34; + \
               f&#34;{self.get_function_out_blif()}&#34; + \
               f&#34;.end\n&#34;

    def get_function_blocks_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

        Returns:
            str: Hierarchical Blif code of all subcomponents function blocks description.
        &#34;&#34;&#34;
        # Retrieve all unique component types composing this circuit
        # (iterating backwards as opposed to other representations so the top modul is always above its subcomponents)
        self.component_types = self.get_component_types()
        return &#34;\n&#34;.join([c.get_function_block_blif() for c in self.component_types[::-1]])

    def get_function_block_blif(self):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

        Returns:
            str: Hierarchical Blif code of multi-bit arithmetic circuit&#39;s function block description.
        &#34;&#34;&#34;
        # Obtain proper circuit name with its bit width
        circuit_prefix = self.__class__(
            a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
        circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
            N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
        return f&#34;{circuit_block.get_circuit_blif()}&#34;

    # Generating hierarchical BLIF code representation of circuit
    def get_blif_code_hier(self, file_object):
        &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_circuit_blif()+&#34;\n&#34;)
        file_object.write(self.get_function_blocks_blif())
        file_object.close()

    &#34;&#34;&#34; CGP CODE GENERATION &#34;&#34;&#34;
    # FLAT CGP #

    def get_parameters_cgp(self):
        &#34;&#34;&#34;Generates CGP chromosome parameters of corresponding arithmetic circuit.

        In total seven parameters represent: total inputs, total outputs, number of rows, number of columns (gates),
        number of each gate&#39;s inputs, number of each gate&#39;s outputs, quality constant value.

        Returns:
            str: CGP chromosome parameters of described arithmetic circuit.
        &#34;&#34;&#34;
        self.circuit_gates = self.get_circuit_gates()
        return f&#34;{{{self.a.N+self.a.N},{self.out.N},1,{len(self.circuit_gates)},2,1,0}}&#34;

    def get_triplets_cgp(self):
        &#34;&#34;&#34;Generates list of logic gate triplets (first input wire, second input wire, logic gate function) using wires unique position indexes within the described circuit.

        Each triplet represents unique logic gate within the described arithmetic circuit. Besides the contained input wires indexes and gate&#39;s inner logic function, an output wire
        with incremented index position is also created and remembered to be appropriately driven as an input to another logic gate or as the circuit&#39;s output.

        Constant wire with value 0 has constant index of 0.
        Constant wire with value 1 has constant index of 1.
        Other wires indexes start counting from 2 and up.

        Returns:
            str: List of triplets each describing logic function of corresponding two input logic gate and as a whole describe the arithmetic circuit.
        &#34;&#34;&#34;
        self.get_cgp_wires()
        return &#34;&#34;.join([g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), out_id=self.get_circuit_wire_index(g.out)) if isinstance(g, OneInputLogicGate) else
                       g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), b_id=self.get_circuit_wire_index(g.b), out_id=self.get_circuit_wire_index(g.out)) for g in self.circuit_gates])

    def get_outputs_cgp(self):
        &#34;&#34;&#34;Generates list of output wires indexes of described arithmetic circuit from MSB to LSB.

        Returns:
            str: List of arithmetic circuit&#39;s output wire indexes.
        &#34;&#34;&#34;
        return &#34;(&#34; + &#34;,&#34;.join([str(self.get_circuit_wire_index(o)) for o in self.out.bus]) + &#34;)&#34;

    # Generating flat CGP chromosome representation of circuit
    def get_cgp_code_flat(self, file_object):
        &#34;&#34;&#34;Generates flat CGP chromosome representation of corresponding arithmetic circuit.

        Args:
            file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
        &#34;&#34;&#34;
        file_object.write(self.get_parameters_cgp())
        file_object.write(self.get_triplets_cgp())
        file_object.write(self.get_outputs_cgp())
        file_object.close()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_includes_c"><code class="name flex">
<span>def <span class="ident">get_includes_c</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates necessary C library includes for output representation.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>C code library includes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_includes_c():
    &#34;&#34;&#34;Generates necessary C library includes for output representation.

    Returns:
        str: C code library includes.
    &#34;&#34;&#34;
    return f&#34;#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_unique_types"><code class="name flex">
<span>def <span class="ident">get_unique_types</span></span>(<span>components: list)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves just the unique representatives of class types present inside the provided components list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>components</code></strong> :&ensp;<code>list</code></dt>
<dd>List of components to be filtered.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of unique composite class types.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_unique_types(components: list):
    &#34;&#34;&#34;Retrieves just the unique representatives of class types present inside the provided components list.

    Args:
        components (list): List of components to be filtered.

    Returns:
        list: List of unique composite class types.
    &#34;&#34;&#34;
    return list({type(c): c for c in components}.values())</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.add_component"><code class="name flex">
<span>def <span class="ident">add_component</span></span>(<span>self, component)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a component into list of circuit's inner subcomponents.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>component</code></strong></dt>
<dd>Subcomponent to be added into list of components composing described circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_component(self, component):
    &#34;&#34;&#34;Adds a component into list of circuit&#39;s inner subcomponents.

    Args:
        component: Subcomponent to be added into list of components composing described circuit.
    &#34;&#34;&#34;
    self.components.append(component)
    return component</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_flat"><code class="name flex">
<span>def <span class="ident">get_blif_code_flat</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Blif code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blif_code_flat(self, file_object):
    &#34;&#34;&#34;Generates flat Blif code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_prototype_blif())
    file_object.write(self.get_declaration_blif())
    file_object.write(self.get_function_blif_flat())
    file_object.write(self.get_function_out_blif())
    file_object.write(f&#34;.end\n&#34;)
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_hier"><code class="name flex">
<span>def <span class="ident">get_blif_code_hier</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_blif_code_hier(self, file_object):
    &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_circuit_blif()+&#34;\n&#34;)
    file_object.write(self.get_function_blocks_blif())
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_flat"><code class="name flex">
<span>def <span class="ident">get_c_code_flat</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat C code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_c_code_flat(self, file_object):
    &#34;&#34;&#34;Generates flat C code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_includes_c())
    file_object.write(self.get_prototype_c())
    file_object.write(self.out.get_declaration_c())
    file_object.write(self.get_declaration_c_flat()+&#34;\n&#34;)
    file_object.write(self.get_init_c_flat()+&#34;\n&#34;)
    file_object.write(self.get_function_out_c_flat())
    file_object.write(f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;)
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_hier"><code class="name flex">
<span>def <span class="ident">get_c_code_hier</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_c_code_hier(self, file_object):
    &#34;&#34;&#34;Generates hierarchical C code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_includes_c())
    file_object.write(self.get_function_blocks_c())
    file_object.write(self.get_circuit_c())
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_carry_wire"><code class="name flex">
<span>def <span class="ident">get_carry_wire</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get output wire carrying carry out value.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Wire</code></dt>
<dd>Return carry out wire.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_carry_wire(self):
    &#34;&#34;&#34;Get output wire carrying carry out value.

    Returns:
       Wire: Return carry out wire.
    &#34;&#34;&#34;
    return self.out.get_wire(1)</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_code_flat"><code class="name flex">
<span>def <span class="ident">get_cgp_code_flat</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat CGP chromosome representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cgp_code_flat(self, file_object):
    &#34;&#34;&#34;Generates flat CGP chromosome representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_parameters_cgp())
    file_object.write(self.get_triplets_cgp())
    file_object.write(self.get_outputs_cgp())
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_wires"><code class="name flex">
<span>def <span class="ident">get_cgp_wires</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of all wires in circuit along with their index position for cgp chromosome generation and stores them inside <code>self.circuit_wires</code> list.</p>
<p>Constant wire with value 0 has constant index of 0.
Constant wire with value 1 has constant index of 1.
Other wires indexes start counting from 2 and up.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cgp_wires(self):
    &#34;&#34;&#34;Gets a list of all wires in circuit along with their index position for cgp chromosome generation and stores them inside `self.circuit_wires` list.

    Constant wire with value 0 has constant index of 0.
    Constant wire with value 1 has constant index of 1.
    Other wires indexes start counting from 2 and up.
    &#34;&#34;&#34;
    self.circuit_wires = []
    if isinstance(self.a, Bus):
        [self.circuit_wires.append(
            (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.a.bus]
        [self.circuit_wires.append(
            (w, f&#34;{w.name}&#34;, self.save_wire_id(wire=w))) for w in self.b.bus]
    else:
        self.circuit_wires.append(
            (self.a, f&#34;{self.a.name}&#34;, self.save_wire_id(wire=self.a)))
        self.circuit_wires.append(
            (self.b, f&#34;{self.b.name}&#34;, self.save_wire_id(wire=self.b)))
        if hasattr(self, &#39;c&#39;):
            self.circuit_wires.append(
                (self.c, f&#34;{self.c.name}&#34;, self.save_wire_id(wire=self.c)))

    for gate in self.circuit_gates:
        if not [item for item in self.circuit_wires if gate.a.name == item[1]]:
            self.circuit_wires.append(
                (gate.a, gate.a.name, self.save_wire_id(wire=gate.a)))

        if hasattr(gate, &#39;b&#39;) and not [item for item in self.circuit_wires if gate.b.name == item[1]]:
            self.circuit_wires.append(
                (gate.b, gate.b.name, self.save_wire_id(wire=gate.b)))

        if not [item for item in self.circuit_wires if gate.out.name == item[1]]:
            self.circuit_wires.append(
                (gate.out, gate.out.name, self.save_wire_id(wire=gate.out)))</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_blif"><code class="name flex">
<span>def <span class="ident">get_circuit_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code subcomponent's function block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Blif code of subcomponent's function block.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circuit_blif(self):
    &#34;&#34;&#34;Generates hierarchical Blif code subcomponent&#39;s function block.

    Returns:
        str: Hierarchical Blif code of subcomponent&#39;s function block.
    &#34;&#34;&#34;
    return f&#34;{self.get_prototype_blif()}&#34; + \
           f&#34;{self.get_declaration_blif()}&#34; + \
           f&#34;{self.get_invocations_blif_hier()}&#34; + \
           f&#34;{self.get_function_out_blif()}&#34; + \
           f&#34;.end\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_c"><code class="name flex">
<span>def <span class="ident">get_circuit_c</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code subcomponent's function block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code of subcomponent's function block.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circuit_c(self):
    &#34;&#34;&#34;Generates hierarchical C code subcomponent&#39;s function block.

    Returns:
        str: Hierarchical C code of subcomponent&#39;s function block.
    &#34;&#34;&#34;
    return f&#34;{self.get_prototype_c()}&#34; + \
           f&#34;{self.out.get_declaration_c()}&#34; + \
           f&#34;{self.get_declarations_c_hier()}\n&#34; + \
           f&#34;{self.get_init_c_hier()}\n&#34; + \
           f&#34;{self.get_function_out_c_hier()}&#34; + \
           f&#34;  return {self.out.prefix}&#34;+&#34;;\n}&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_gates"><code class="name flex">
<span>def <span class="ident">get_circuit_gates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets a list of all the logic gates in circuit that should be generated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of composite logic gates.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circuit_gates(self):
    &#34;&#34;&#34;Gets a list of all the logic gates in circuit that should be generated.

    Returns:
        list: List of composite logic gates.
    &#34;&#34;&#34;
    gates = []
    for c in self.components:
        if isinstance(c, TwoInputLogicGate):
            if c.disable_generation is False:
                gates.append(c)
        else:
            gates.extend((c.get_circuit_gates()))
    return gates</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_v"><code class="name flex">
<span>def <span class="ident">get_circuit_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code subcomponent's function block.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code of subcomponent's function block.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circuit_v(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code subcomponent&#39;s function block.

    Returns:
        str: Hierarchical Verilog code of subcomponent&#39;s function block.
    &#34;&#34;&#34;
    return f&#34;{self.get_prototype_v()}&#34; + \
           f&#34;{self.get_declarations_v_hier()}\n&#34; + \
           f&#34;{self.get_init_v_hier()}\n&#34; + \
           f&#34;{self.get_function_out_v_hier()}&#34; + \
           f&#34;endmodule&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_wire_index"><code class="name flex">
<span>def <span class="ident">get_circuit_wire_index</span></span>(<span>self, wire: <a title="ariths_gen.wire_components.wires.Wire" href="../../wire_components/wires.html#ariths_gen.wire_components.wires.Wire">Wire</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Searches for circuit's wire unique index position within the circuit. Used for cgp chromosome generation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wire</code></strong> :&ensp;<code>Wire</code></dt>
<dd>Wire to retrieve index position of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Wire's index position number within the circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circuit_wire_index(self, wire: Wire):
    &#34;&#34;&#34;Searches for circuit&#39;s wire unique index position within the circuit. Used for cgp chromosome generation.

    Args:
        wire (Wire): Wire to retrieve index position of.

    Returns:
        int: Wire&#39;s index position number within the circuit.
    &#34;&#34;&#34;
    if wire.is_const():
        return wire.cgp_const
    else:
        for w in self.circuit_wires:
            if wire.name == w[1]:
                return w[2]</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_component_types"><code class="name flex">
<span>def <span class="ident">get_component_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all the unique types of subcomponents composing the circuit.</p>
<p>Returning list consists of only the unique types of logic gates, one bit circuits and multi bit circuits.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of unique component types describing the circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_component_types(self):
    &#34;&#34;&#34;Retrieves a list of all the unique types of subcomponents composing the circuit.

    Returning list consists of only the unique types of logic gates, one bit circuits and multi bit circuits.

    Returns:
        list: List of unique component types describing the circuit.
    &#34;&#34;&#34;
    gate_comps = self.get_unique_types(components=self.get_circuit_gates())
    one_bit_comps = self.get_unique_types(
        components=self.get_one_bit_components())
    multi_bit_comps = self.get_unique_types(
        components=self.get_multi_bit_components())

    all_components = gate_comps + one_bit_comps + multi_bit_comps
    return all_components</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_blif"><code class="name flex">
<span>def <span class="ident">get_declaration_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Blif code declaration of input/output circuit wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Blif code containing declaration of circuit's wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declaration_blif(self):
    &#34;&#34;&#34;Generates flat Blif code declaration of input/output circuit wires.

    Returns:
        str: Flat Blif code containing declaration of circuit&#39;s wires.
    &#34;&#34;&#34;
    if self.N == 1:
        return f&#34;.inputs {self.a.prefix} {self.b.prefix}\n&#34; + \
               f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
               f&#34;.names vdd\n1\n&#34; + \
               f&#34;.names gnd\n0\n&#34;
    else:
        return f&#34;.inputs{self.a.get_wire_declaration_blif()}{self.b.get_wire_declaration_blif()}\n&#34; + \
               f&#34;.outputs{self.out.get_wire_declaration_blif()}\n&#34; + \
               f&#34;.names vdd\n1\n&#34; + \
               f&#34;.names gnd\n0\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_flat"><code class="name flex">
<span>def <span class="ident">get_declaration_c_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat C code declaration of input/output circuit wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat C code arithmetic circuit's wires declaration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declaration_c_flat(self):
    &#34;&#34;&#34;Generates flat C code declaration of input/output circuit wires.

    Returns:
        str: Flat C code arithmetic circuit&#39;s wires declaration.
    &#34;&#34;&#34;
    return f&#34;&#34;.join([c.get_declaration_c_flat() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_hier"><code class="name flex">
<span>def <span class="ident">get_declaration_c_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code declaration of corresponding subcomponent input/output wires inside the upper component.</p>
<p>Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
inside the upper component from which function block has been invoked.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code of subcomponent arithmetic circuit's wires declaration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declaration_c_hier(self):
    &#34;&#34;&#34;Generates hierarchical C code declaration of corresponding subcomponent input/output wires inside the upper component.

    Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
    inside the upper component from which function block has been invoked.

    Returns:
        str: Hierarchical C code of subcomponent arithmetic circuit&#39;s wires declaration.
    &#34;&#34;&#34;
    return f&#34;  {self.c_data_type} {self.a.prefix} = 0;\n&#34; + \
           f&#34;  {self.c_data_type} {self.b.prefix} = 0;\n&#34; + \
           f&#34;  {self.c_data_type} {self.out.prefix} = 0;\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_flat"><code class="name flex">
<span>def <span class="ident">get_declaration_v_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Verilog code declaration of input/output circuit wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Verilog code arithmetic circuit's wires declaration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declaration_v_flat(self):
    &#34;&#34;&#34;Generates flat Verilog code declaration of input/output circuit wires.

    Returns:
        str: Flat Verilog code arithmetic circuit&#39;s wires declaration.
    &#34;&#34;&#34;
    return f&#34;&#34;.join([c.get_declaration_v_flat() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_hier"><code class="name flex">
<span>def <span class="ident">get_declaration_v_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code declaration of corresponding subcomponent input/output wires inside the upper component.</p>
<p>Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
inside the upper component from which function block has been invoked.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code of subcomponent arithmetic circuit's wires declaration.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declaration_v_hier(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code declaration of corresponding subcomponent input/output wires inside the upper component.

    Generates wires used to connect input/output values to/from invocation of the corresponding function block into inner wires present
    inside the upper component from which function block has been invoked.

    Returns:
        str: Hierarchical Verilog code of subcomponent arithmetic circuit&#39;s wires declaration.
    &#34;&#34;&#34;
    return f&#34;  wire [{self.a.N-1}:0] {self.a.prefix};\n&#34; + \
           f&#34;  wire [{self.b.N-1}:0] {self.b.prefix};\n&#34; + \
           f&#34;  wire [{self.out.N-1}:0] {self.out.prefix};\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_c_hier"><code class="name flex">
<span>def <span class="ident">get_declarations_c_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code declaration of input/output circuit wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code containing unique declaration of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declarations_c_hier(self):
    &#34;&#34;&#34;Generates hierarchical C code declaration of input/output circuit wires.

    Returns:
        str: Hierarchical C code containing unique declaration of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_declaration_c_hier() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_v_hier"><code class="name flex">
<span>def <span class="ident">get_declarations_v_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code declaration of input/output circuit wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code containing unique declaration of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_declarations_v_hier(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code declaration of input/output circuit wires.

    Returns:
        str: Hierarchical Verilog code containing unique declaration of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_declaration_v_hier() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blif_flat"><code class="name flex">
<span>def <span class="ident">get_function_blif_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Blif code with invocation of subcomponents logic gates functions via their corresponding truth tables.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Blif code containing invocation of inner subcomponents logic gates Boolean functions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_blif_flat(self):
    &#34;&#34;&#34;Generates flat Blif code with invocation of subcomponents logic gates functions via their corresponding truth tables.

    Returns:
        str: Flat Blif code containing invocation of inner subcomponents logic gates Boolean functions.
    &#34;&#34;&#34;
    return &#34;&#34;.join(c.get_function_blif_flat() for c in self.components)</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_blif"><code class="name flex">
<span>def <span class="ident">get_function_block_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Blif code of multi-bit arithmetic circuit's function block description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_block_blif(self):
    &#34;&#34;&#34;Generates hierarchical Blif code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

    Returns:
        str: Hierarchical Blif code of multi-bit arithmetic circuit&#39;s function block description.
    &#34;&#34;&#34;
    # Obtain proper circuit name with its bit width
    circuit_prefix = self.__class__(
        a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
    circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
        N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
    return f&#34;{circuit_block.get_circuit_blif()}&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_c"><code class="name flex">
<span>def <span class="ident">get_function_block_c</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code of multi-bit arithmetic circuit's function block description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_block_c(self):
    &#34;&#34;&#34;Generates hierarchical C code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

    Returns:
        str: Hierarchical C code of multi-bit arithmetic circuit&#39;s function block description.
    &#34;&#34;&#34;
    # Obtain proper circuit name with its bit width
    circuit_prefix = self.__class__(
        a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
    circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
        N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
    return f&#34;{circuit_block.get_circuit_c()}\n\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_v"><code class="name flex">
<span>def <span class="ident">get_function_block_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code of multi-bit arithmetic circuit's function block description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_block_v(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding multi-bit arithmetic circuit used as function block in hierarchical circuit description.

    Returns:
        str: Hierarchical Verilog code of multi-bit arithmetic circuit&#39;s function block description.
    &#34;&#34;&#34;
    # Obtain proper circuit name with its bit width
    circuit_prefix = self.__class__(
        a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
    circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
        N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
    return f&#34;{circuit_block.get_circuit_v()}\n\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_blif"><code class="name flex">
<span>def <span class="ident">get_function_blocks_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code representation of all subcomponents function blocks present in corresponding arithmetic circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Blif code of all subcomponents function blocks description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_blocks_blif(self):
    &#34;&#34;&#34;Generates hierarchical Blif code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

    Returns:
        str: Hierarchical Blif code of all subcomponents function blocks description.
    &#34;&#34;&#34;
    # Retrieve all unique component types composing this circuit
    # (iterating backwards as opposed to other representations so the top modul is always above its subcomponents)
    self.component_types = self.get_component_types()
    return &#34;\n&#34;.join([c.get_function_block_blif() for c in self.component_types[::-1]])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_c"><code class="name flex">
<span>def <span class="ident">get_function_blocks_c</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code representation of all subcomponents function blocks present in corresponding arithmetic circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code of all subcomponents function blocks description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_blocks_c(self):
    &#34;&#34;&#34;Generates hierarchical C code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

    Returns:
        str: Hierarchical C code of all subcomponents function blocks description.
    &#34;&#34;&#34;
    # Retrieve all unique component types composing this circuit
    self.component_types = self.get_component_types()
    return &#34;&#34;.join([c.get_function_block_c() for c in self.component_types])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_v"><code class="name flex">
<span>def <span class="ident">get_function_blocks_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code representation of all subcomponents function blocks present in corresponding arithmetic circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code of all subcomponents function blocks description.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_blocks_v(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code representation of all subcomponents function blocks present in corresponding arithmetic circuit.

    Returns:
        str: Hierarchical Verilog code of all subcomponents function blocks description.
    &#34;&#34;&#34;
    # Retrieve all unique component types composing this circuit
    self.component_types = self.get_component_types()
    return &#34;&#34;.join([c.get_function_block_v() for c in self.component_types])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_blif"><code class="name flex">
<span>def <span class="ident">get_function_out_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Blif code assignment of corresponding arithmetic circuit's output bus wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Blif code containing output bus wires assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_out_blif(self):
    &#34;&#34;&#34;Generates flat Blif code assignment of corresponding arithmetic circuit&#39;s output bus wires.

    Returns:
        str: Flat Blif code containing output bus wires assignment.
    &#34;&#34;&#34;
    return f&#34;{self.out.get_wire_assign_blif(output=True)}&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_flat"><code class="name flex">
<span>def <span class="ident">get_function_out_c_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat C code assignment of corresponding arithmetic circuit's output bus wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat C code containing output bus wires assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_out_c_flat(self):
    &#34;&#34;&#34;Generates flat C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

    Returns:
        str: Flat C code containing output bus wires assignment.
    &#34;&#34;&#34;
    return self.out.return_bus_wires_values_c_flat()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_hier"><code class="name flex">
<span>def <span class="ident">get_function_out_c_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code assignment of corresponding arithmetic circuit's output bus wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code containing output bus wires assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_out_c_hier(self):
    &#34;&#34;&#34;Generates hierarchical C code assignment of corresponding arithmetic circuit&#39;s output bus wires.

    Returns:
        str: Hierarchical C code containing output bus wires assignment.
    &#34;&#34;&#34;
    return self.out.return_bus_wires_values_c_hier()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_flat"><code class="name flex">
<span>def <span class="ident">get_function_out_v_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Verilog code assignment of corresponding arithmetic circuit's output bus wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Verilog code containing output bus wires assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_out_v_flat(self):
    &#34;&#34;&#34;Generates flat Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

    Returns:
        str: Flat Verilog code containing output bus wires assignment.
    &#34;&#34;&#34;
    return self.out.return_bus_wires_values_v_flat()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_hier"><code class="name flex">
<span>def <span class="ident">get_function_out_v_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code assignment of corresponding arithmetic circuit's output bus wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code containing output bus wires assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_function_out_v_hier(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code assignment of corresponding arithmetic circuit&#39;s output bus wires.

    Returns:
        str: Hierarchical Verilog code containing output bus wires assignment.
    &#34;&#34;&#34;
    return self.out.return_bus_wires_values_v_hier()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_flat"><code class="name flex">
<span>def <span class="ident">get_init_c_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat C code initialization and assignment of corresponding arithmetic circuit's input/output wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat C code initialization of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_init_c_flat(self):
    &#34;&#34;&#34;Generates flat C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

    Returns:
        str: Flat C code initialization of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_assign_c_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_c_flat() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_hier"><code class="name flex">
<span>def <span class="ident">get_init_c_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code initialization and assignment of corresponding arithmetic circuit's input/output wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code initialization of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_init_c_hier(self):
    &#34;&#34;&#34;Generates hierarchical C code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

    Returns:
        str: Hierarchical C code initialization of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_gate_invocation_c() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_c(circuit_prefix=self.prefix) for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_flat"><code class="name flex">
<span>def <span class="ident">get_init_v_flat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Verilog code initialization and assignment of corresponding arithmetic circuit's input/output buses wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Flat Verilog code initialization of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_init_v_flat(self):
    &#34;&#34;&#34;Generates flat Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output buses wires.

    Returns:
        str: Flat Verilog code initialization of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_assign_v_flat() if isinstance(c, TwoInputLogicGate) else c.get_init_v_flat() for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_hier"><code class="name flex">
<span>def <span class="ident">get_init_v_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code initialization and assignment of corresponding arithmetic circuit's input/output wires.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code initialization of arithmetic circuit wires.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_init_v_hier(self):
    &#34;&#34;&#34;Generates hierarchical Verilog code initialization and assignment of corresponding arithmetic circuit&#39;s input/output wires.

    Returns:
        str: Hierarchical Verilog code initialization of arithmetic circuit wires.
    &#34;&#34;&#34;
    return &#34;&#34;.join([c.get_gate_invocation_v() if isinstance(c, TwoInputLogicGate) else c.get_out_invocation_v(circuit_prefix=self.prefix) for c in self.components])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_instance_num"><code class="name flex">
<span>def <span class="ident">get_instance_num</span></span>(<span>self, cls, count_disabled_gates: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Informs how many instances of the same type are already present inside circuit's components list.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cls</code></strong> :&ensp;<code>type</code></dt>
<dd>Class type for which to count the number of instances in the components list.</dd>
<dt><strong><code>count_disabled_gates</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Indicates whether logic gates that aren't generated should be also counted. Defaults to True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Number of instances of the same class type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instance_num(self, cls, count_disabled_gates: bool = True):
    &#34;&#34;&#34;Informs how many instances of the same type are already present inside circuit&#39;s components list.

    Args:
        cls (type): Class type for which to count the number of instances in the components list.
        count_disabled_gates (bool, optional): Indicates whether logic gates that aren&#39;t generated should be also counted. Defaults to True.
    Returns:
        int: Number of instances of the same class type.
    &#34;&#34;&#34;
    if issubclass(cls, TwoInputLogicGate) and count_disabled_gates is False:
        return sum(isinstance(c, cls) for c in self.components if isinstance(c, cls) and c.disable_generation is False)
    else:
        return sum(isinstance(c, cls) for c in self.components)</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocation_blif_hier"><code class="name flex">
<span>def <span class="ident">get_invocation_blif_hier</span></span>(<span>self, circuit_prefix: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code invocation of corresponding arithmetic circuit's generated function block.</p>
<p>Used for multi-bit subcomponent's modul invocation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>circuit_prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Prefix name of the upper component from which function block is being invoked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Blif code of subcomponent's model invocation and output assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_invocation_blif_hier(self, circuit_prefix: str):
    &#34;&#34;&#34;Generates hierarchical Blif code invocation of corresponding arithmetic circuit&#39;s generated function block.

    Used for multi-bit subcomponent&#39;s modul invocation.

    Args:
        circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

    Returns:
        str: Hierarchical Blif code of subcomponent&#39;s model invocation and output assignment.
    &#34;&#34;&#34;
    # Getting name of circuit type for proper Blif code generation without affecting actual generated composition
    circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
    return f&#34;{self.a.get_wire_assign_blif(output=True)}&#34; + \
           f&#34;{self.b.get_wire_assign_blif(output=True)}&#34; + \
           f&#34;.subckt {circuit_type}&#34; + \
           &#34;&#34;.join([f&#34; a[{self.a.bus.index(w)}]={self.a.prefix}[{self.a.bus.index(w)}]&#34; for w in self.a.bus]) + \
           &#34;&#34;.join([f&#34; b[{self.b.bus.index(w)}]={self.b.prefix}[{self.b.bus.index(w)}]&#34; for w in self.b.bus]) + \
           &#34;&#34;.join(
               [f&#34; {circuit_type}_out[{self.out.bus.index(o)}]={o.name}&#34; for o in self.out.bus]) + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocations_blif_hier"><code class="name flex">
<span>def <span class="ident">get_invocations_blif_hier</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Blif code with invocations of subcomponents function blocks.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Blif code containing invocations of inner subcomponents function blocks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_invocations_blif_hier(self):
    &#34;&#34;&#34;Generates hierarchical Blif code with invocations of subcomponents function blocks.

    Returns:
        str: Hierarchical Blif code containing invocations of inner subcomponents function blocks.
    &#34;&#34;&#34;
    return &#34;&#34;.join(c.get_invocation_blif_hier(circuit_prefix=self.prefix) for c in self.components)</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_multi_bit_components"><code class="name flex">
<span>def <span class="ident">get_multi_bit_components</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all the multi bit circuits present as subcomponents inside the circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of composite multi bit circuits.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_multi_bit_components(self):
    &#34;&#34;&#34;Retrieves a list of all the multi bit circuits present as subcomponents inside the circuit.

    Returns:
        list: List of composite multi bit circuits.
    &#34;&#34;&#34;
    multi_bit_comps = []
    for c in self.components:
        if isinstance(c, TwoInputLogicGate):
            continue
        elif isinstance(getattr(c, &#39;a&#39;), Wire):
            continue
        else:
            multi_bit_comps.append(c)
    return multi_bit_comps</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_one_bit_components"><code class="name flex">
<span>def <span class="ident">get_one_bit_components</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a list of all the one bit circuits (besides logic gates) present as subcomponents inside the circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of composite one bit circuits.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_one_bit_components(self):
    &#34;&#34;&#34;Retrieves a list of all the one bit circuits (besides logic gates) present as subcomponents inside the circuit.

    Returns:
        list: List of composite one bit circuits.
    &#34;&#34;&#34;
    one_bit_comps = []
    for c in self.components:
        if isinstance(c, TwoInputLogicGate):
            continue
        elif isinstance(getattr(c, &#39;a&#39;), Wire):
            one_bit_comps.append(c)
        else:
            one_bit_comps.extend(c.get_one_bit_components())

    return one_bit_comps</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_c"><code class="name flex">
<span>def <span class="ident">get_out_invocation_c</span></span>(<span>self, circuit_prefix: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical C code invocation of corresponding arithmetic circuit's generated function block.</p>
<p>Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
Assigns output values from invocation of the corresponding function block into inner wires present inside
the upper component from which function block has been invoked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>circuit_prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Prefix name of the upper component from which function block is being invoked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical C code of subcomponent's C function invocation and output assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_out_invocation_c(self, circuit_prefix: str):
    &#34;&#34;&#34;Generates hierarchical C code invocation of corresponding arithmetic circuit&#39;s generated function block.

    Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
    Assigns output values from invocation of the corresponding function block into inner wires present inside
    the upper component from which function block has been invoked.

    Args:
        circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

    Returns:
        str: Hierarchical C code of subcomponent&#39;s C function invocation and output assignment.
    &#34;&#34;&#34;
    # Getting name of circuit type for proper C code generation without affecting actual generated composition
    circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)
    return self.a.return_bus_wires_values_c_hier() + self.b.return_bus_wires_values_c_hier() + \
        f&#34;  {self.out.prefix} = {circuit_type}({self.a.prefix}, {self.b.prefix});\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_v"><code class="name flex">
<span>def <span class="ident">get_out_invocation_v</span></span>(<span>self, circuit_prefix: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code invocation of corresponding arithmetic circuit's generated function block.</p>
<p>Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
Assigns output values from invocation of the corresponding function block into inner wires present inside
the upper component from which function block has been invoked.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>circuit_prefix</code></strong> :&ensp;<code>str</code></dt>
<dd>Prefix name of the upper component from which function block is being invoked.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Hierarchical Verilog code of subcomponent's module invocation and output assignment.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_out_invocation_v(self, circuit_prefix: str):
    &#34;&#34;&#34;Generates hierarchical Verilog code invocation of corresponding arithmetic circuit&#39;s generated function block.

    Assigns input values from other subcomponents into multi-bit input buses used as inputs for function block invocation.
    Assigns output values from invocation of the corresponding function block into inner wires present inside
    the upper component from which function block has been invoked.

    Args:
        circuit_prefix (str): Prefix name of the upper component from which function block is being invoked.

    Returns:
        str: Hierarchical Verilog code of subcomponent&#39;s module invocation and output assignment.
    &#34;&#34;&#34;
    # Getting name of circuit type and insitu copying out bus for proper Verilog code generation without affecting actual generated composition
    circuit_type = self.prefix.replace(circuit_prefix+&#34;_&#34;, &#34;&#34;)

    # Obtain proper circuit name with its bit width
    circuit_prefix = self.__class__(
        a=Bus(&#34;a&#34;), b=Bus(&#34;b&#34;)).prefix + str(self.N)
    circuit_block = self.__class__(a=Bus(N=self.N, prefix=&#34;a&#34;), b=Bus(
        N=self.N, prefix=&#34;b&#34;), prefix=circuit_prefix)
    return self.a.return_bus_wires_values_v_hier() + self.b.return_bus_wires_values_v_hier() + \
        f&#34;  {circuit_type} {circuit_type}_{self.out.prefix}(.{circuit_block.a.prefix}({self.a.prefix}), .{circuit_block.b.prefix}({self.b.prefix}), .{circuit_block.out.prefix}({self.out.prefix}));\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_outputs_cgp"><code class="name flex">
<span>def <span class="ident">get_outputs_cgp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates list of output wires indexes of described arithmetic circuit from MSB to LSB.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>List of arithmetic circuit's output wire indexes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_outputs_cgp(self):
    &#34;&#34;&#34;Generates list of output wires indexes of described arithmetic circuit from MSB to LSB.

    Returns:
        str: List of arithmetic circuit&#39;s output wire indexes.
    &#34;&#34;&#34;
    return &#34;(&#34; + &#34;,&#34;.join([str(self.get_circuit_wire_index(o)) for o in self.out.bus]) + &#34;)&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_parameters_cgp"><code class="name flex">
<span>def <span class="ident">get_parameters_cgp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates CGP chromosome parameters of corresponding arithmetic circuit.</p>
<p>In total seven parameters represent: total inputs, total outputs, number of rows, number of columns (gates),
number of each gate's inputs, number of each gate's outputs, quality constant value.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>CGP chromosome parameters of described arithmetic circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameters_cgp(self):
    &#34;&#34;&#34;Generates CGP chromosome parameters of corresponding arithmetic circuit.

    In total seven parameters represent: total inputs, total outputs, number of rows, number of columns (gates),
    number of each gate&#39;s inputs, number of each gate&#39;s outputs, quality constant value.

    Returns:
        str: CGP chromosome parameters of described arithmetic circuit.
    &#34;&#34;&#34;
    self.circuit_gates = self.get_circuit_gates()
    return f&#34;{{{self.a.N+self.a.N},{self.out.N},1,{len(self.circuit_gates)},2,1,0}}&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_previous_component"><code class="name flex">
<span>def <span class="ident">get_previous_component</span></span>(<span>self, number: int = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves previously added composite subcomponent from circuit's list of components.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Offset indicating which lastly added component will be retrieved. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>component</code></dt>
<dd>Desired previously added composite component.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_previous_component(self, number: int = 1):
    &#34;&#34;&#34;Retrieves previously added composite subcomponent from circuit&#39;s list of components.

    Args:
        number (int, optional): Offset indicating which lastly added component will be retrieved. Defaults to 1.

    Returns:
        component: Desired previously added composite component.
    &#34;&#34;&#34;
    return self.components[-number]</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_blif"><code class="name flex">
<span>def <span class="ident">get_prototype_blif</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates Blif code model name of described arithmetic circuit.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Model's name in Blif code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prototype_blif(self):
    &#34;&#34;&#34;Generates Blif code model name of described arithmetic circuit.

    Returns:
        str: Model&#39;s name in Blif code.
    &#34;&#34;&#34;
    return f&#34;.model {self.prefix}\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_c"><code class="name flex">
<span>def <span class="ident">get_prototype_c</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates C code function header to describe corresponding arithmetic circuit's interface in C code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Function's name and parameters in C code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prototype_c(self):
    &#34;&#34;&#34;Generates C code function header to describe corresponding arithmetic circuit&#39;s interface in C code.

    Returns:
        str: Function&#39;s name and parameters in C code.
    &#34;&#34;&#34;
    return f&#34;{self.c_data_type} {self.prefix}(&#34; + &#34;,&#34;.join([f&#34;{self.c_data_type} {x.prefix}&#34; for x in self.inputs]) + &#34;)&#34; + &#34;{&#34; + &#34;\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_v"><code class="name flex">
<span>def <span class="ident">get_prototype_v</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates Verilog code module header to describe corresponding arithmetic circuit's interface in Verilog code.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Module's name and parameters in Verilog code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_prototype_v(self):
    &#34;&#34;&#34;Generates Verilog code module header to describe corresponding arithmetic circuit&#39;s interface in Verilog code.

    Returns:
        str: Module&#39;s name and parameters in Verilog code.
    &#34;&#34;&#34;
    return f&#34;module {self.prefix}(&#34; + &#34;,&#34;.join(f&#34;input [{x.N-1}:0] {x.prefix}&#34; for x in self.inputs) + f&#34;, output [{self.out.N-1}:0] {self.out.prefix});\n&#34;</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_sum_wire"><code class="name flex">
<span>def <span class="ident">get_sum_wire</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get output wire carrying sum value.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Wire</code></dt>
<dd>Return sum wire.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sum_wire(self):
    &#34;&#34;&#34;Get output wire carrying sum value.

    Returns:
       Wire: Return sum wire.
    &#34;&#34;&#34;
    return self.out.get_wire(0)</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_triplets_cgp"><code class="name flex">
<span>def <span class="ident">get_triplets_cgp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates list of logic gate triplets (first input wire, second input wire, logic gate function) using wires unique position indexes within the described circuit.</p>
<p>Each triplet represents unique logic gate within the described arithmetic circuit. Besides the contained input wires indexes and gate's inner logic function, an output wire
with incremented index position is also created and remembered to be appropriately driven as an input to another logic gate or as the circuit's output.</p>
<p>Constant wire with value 0 has constant index of 0.
Constant wire with value 1 has constant index of 1.
Other wires indexes start counting from 2 and up.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>List of triplets each describing logic function of corresponding two input logic gate and as a whole describe the arithmetic circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_triplets_cgp(self):
    &#34;&#34;&#34;Generates list of logic gate triplets (first input wire, second input wire, logic gate function) using wires unique position indexes within the described circuit.

    Each triplet represents unique logic gate within the described arithmetic circuit. Besides the contained input wires indexes and gate&#39;s inner logic function, an output wire
    with incremented index position is also created and remembered to be appropriately driven as an input to another logic gate or as the circuit&#39;s output.

    Constant wire with value 0 has constant index of 0.
    Constant wire with value 1 has constant index of 1.
    Other wires indexes start counting from 2 and up.

    Returns:
        str: List of triplets each describing logic function of corresponding two input logic gate and as a whole describe the arithmetic circuit.
    &#34;&#34;&#34;
    self.get_cgp_wires()
    return &#34;&#34;.join([g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), out_id=self.get_circuit_wire_index(g.out)) if isinstance(g, OneInputLogicGate) else
                   g.get_triplet_cgp(a_id=self.get_circuit_wire_index(g.a), b_id=self.get_circuit_wire_index(g.b), out_id=self.get_circuit_wire_index(g.out)) for g in self.circuit_gates])</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_flat"><code class="name flex">
<span>def <span class="ident">get_v_code_flat</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates flat Verilog code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_code_flat(self, file_object):
    &#34;&#34;&#34;Generates flat Verilog code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_prototype_v())
    file_object.write(self.get_declaration_v_flat()+&#34;\n&#34;)
    file_object.write(self.get_init_v_flat() + &#34;\n&#34;)
    file_object.write(self.get_function_out_v_flat())
    file_object.write(f&#34;endmodule&#34;)
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_hier"><code class="name flex">
<span>def <span class="ident">get_v_code_hier</span></span>(<span>self, file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates hierarchical Verilog code representation of corresponding arithmetic circuit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong> :&ensp;<code>TextIOWrapper</code></dt>
<dd>Destination file object where circuit's representation will be written to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_v_code_hier(self, file_object):
    &#34;&#34;&#34;Generates hierarchical Verilog code representation of corresponding arithmetic circuit.

    Args:
        file_object (TextIOWrapper): Destination file object where circuit&#39;s representation will be written to.
    &#34;&#34;&#34;
    file_object.write(self.get_function_blocks_v())
    file_object.write(self.get_circuit_v())
    file_object.close()</code></pre>
</details>
</dd>
<dt id="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.save_wire_id"><code class="name flex">
<span>def <span class="ident">save_wire_id</span></span>(<span>self, wire: <a title="ariths_gen.wire_components.wires.Wire" href="../../wire_components/wires.html#ariths_gen.wire_components.wires.Wire">Wire</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns appropriate wire index position within the circuit.</p>
<p>Constant wire with value 0 has constant index of 0.
Constant wire with value 1 has constant index of 1.
Other wires indexes start counting from 2 and up.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>wire</code></strong> :&ensp;<code>Wire</code></dt>
<dd>Wire that will be stored at this circuit index position.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>Wire's index position within circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_wire_id(self, wire: Wire):
    &#34;&#34;&#34;Returns appropriate wire index position within the circuit.

    Constant wire with value 0 has constant index of 0.
    Constant wire with value 1 has constant index of 1.
    Other wires indexes start counting from 2 and up.

    Args:
        wire (Wire): Wire that will be stored at this circuit index position.

    Returns:
        int: Wire&#39;s index position within circuit.
    &#34;&#34;&#34;
    if wire.is_const():
        return wire.cgp_const
    else:
        return len([w[0] for w in self.circuit_wires if w[0].is_const() is False]) + 2</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ariths_gen.core.arithmetic_circuits" href="index.html">ariths_gen.core.arithmetic_circuits</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit">GeneralCircuit</a></code></h4>
<ul class="">
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.add_component" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.add_component">add_component</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_flat">get_blif_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_blif_code_hier">get_blif_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_flat">get_c_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_c_code_hier">get_c_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_carry_wire" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_carry_wire">get_carry_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_code_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_code_flat">get_cgp_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_wires" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_cgp_wires">get_cgp_wires</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_blif">get_circuit_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_c">get_circuit_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_gates" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_gates">get_circuit_gates</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_v" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_v">get_circuit_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_wire_index" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_circuit_wire_index">get_circuit_wire_index</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_component_types" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_component_types">get_component_types</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_blif">get_declaration_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_flat">get_declaration_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_c_hier">get_declaration_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_flat">get_declaration_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declaration_v_hier">get_declaration_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_c_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_c_hier">get_declarations_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_v_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_declarations_v_hier">get_declarations_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blif_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blif_flat">get_function_blif_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_blif">get_function_block_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_c">get_function_block_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_v" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_block_v">get_function_block_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_blif">get_function_blocks_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_c">get_function_blocks_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_v" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_blocks_v">get_function_blocks_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_blif">get_function_out_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_flat">get_function_out_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_c_hier">get_function_out_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_flat">get_function_out_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_function_out_v_hier">get_function_out_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_includes_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_includes_c">get_includes_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_flat">get_init_c_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_c_hier">get_init_c_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_flat">get_init_v_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_init_v_hier">get_init_v_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_instance_num" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_instance_num">get_instance_num</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocation_blif_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocation_blif_hier">get_invocation_blif_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocations_blif_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_invocations_blif_hier">get_invocations_blif_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_multi_bit_components" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_multi_bit_components">get_multi_bit_components</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_one_bit_components" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_one_bit_components">get_one_bit_components</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_c">get_out_invocation_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_v" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_out_invocation_v">get_out_invocation_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_outputs_cgp" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_outputs_cgp">get_outputs_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_parameters_cgp" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_parameters_cgp">get_parameters_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_previous_component" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_previous_component">get_previous_component</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_blif" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_blif">get_prototype_blif</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_c" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_c">get_prototype_c</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_v" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_prototype_v">get_prototype_v</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_sum_wire" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_sum_wire">get_sum_wire</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_triplets_cgp" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_triplets_cgp">get_triplets_cgp</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_unique_types" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_unique_types">get_unique_types</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_flat" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_flat">get_v_code_flat</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_hier" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.get_v_code_hier">get_v_code_hier</a></code></li>
<li><code><a title="ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.save_wire_id" href="#ariths_gen.core.arithmetic_circuits.general_circuit.GeneralCircuit.save_wire_id">save_wire_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>